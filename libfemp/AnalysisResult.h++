#ifndef FEMP_ANALYSIS_RESULT_HPP
#define FEMP_ANALYSIS_RESULT_HPP

#include <map>

#include <boost/tuple/tuple.hpp>
#include <iostream>

#include "Element.h++"
#include "ElementResults/ElementResults.h++"
#include "ElementResults/ResultsRanges.h++"

#include <libla/Matrix.h++>
#include <libla/Vector.h++>

#include "point.h++"


namespace fem
{


/**
Class designed to store all the relevant analysis results which are generated by fem::Analysis and are needed in post-processing
**/
template<typename Scalar>
struct AnalysisResult 
{
	AnalysisResult();
	AnalysisResult(const AnalysisResult<Scalar> &);

	// The FEM equation bit
	lalib::Matrix<Scalar,lalib::SparseDOK> K;
	lalib::Vector<Scalar> f;
	lalib::Vector<Scalar> d;

	std::map<size_t, boost::tuple<size_t,size_t,size_t> > lm;


	// A map between the reference to a node and the displacements of it's DoF
	std::map<size_t , fem::point> displacements;

	// map between a element reference and the element's recovered values
	std::map<element_ref_t, ElementResults<Scalar> *> results;

	// this replaces the above code
	ResultsRanges<Scalar>	ranges;


	// the model's energy
	Scalar energy;

	Scalar volume;

	// elapsed time in miliseconds (taken from Qt's qint64
	long long int elapsed_time;	


	void clear();
};


template<typename Scalar>
AnalysisResult<Scalar>::AnalysisResult()
{
	this->clear();
}


template<typename Scalar>
AnalysisResult<Scalar>::AnalysisResult(const AnalysisResult<Scalar> &copied)
{
	this->K = copied.K;
	this->f = copied.f;
	this->d = copied.d;

	this->lm = copied.lm;

	this->displacements = copied.displacements;

	this->results = copied.results;

	this->ranges = copied.ranges;

	this->energy = copied.energy;
	this->volume = copied.volume;

	this->elapsed_time = elapsed_time;
}


template<typename Scalar>
void AnalysisResult<Scalar>::clear()
{
	K.clear();
	f.clear();
	d.clear();

	lm.clear();
	displacements.clear();

	for( typename std::map<element_ref_t, ElementResults<Scalar> *>::iterator i =  results.begin(); i!= results.end(); i++)
	{
		delete i->second;
	}
	results.clear();

	ranges.setZero();

	energy = 0;
	volume = 0;
	this->elapsed_time = 0;
}


}	// namespace fem


#endif
