/* Generated by re2c 0.13.5 on Wed Dec  2 09:03:10 2009 */
#line 1 "parsers/msh.c++.re2c"
#include "msh.h++"

#include <iostream>	// for cerr
#include <cstdlib>


MshParser::MshParser()
{
}


MshParser::~MshParser()
{
}


enum MshParser::Error MshParser::parse(std::string file_name)
{
	return MshParser::P_OK;
}


int MshParser::lexer()
{
std:
	switch(lex_state)
	{
		case 0:
		{
	#define YYFILL(n) { if(file.eof()){ if(tok == lim) return LEX_EOF; }else fill(); }
	
#line 35 "parsers/msh.c++"
{
	char yych;

	if ((lim - pos) < 16) YYFILL(16);
	yych = *pos;
	switch (yych) {
	case '\n':	goto yy4;
	case ' ':	goto yy6;
	case '$':	goto yy2;
	default:	goto yy8;
	}
yy2:
	yych = *(marker = ++pos);
	switch (yych) {
	case 'E':	goto yy11;
	case 'M':	goto yy15;
	case 'N':	goto yy13;
	case 'P':	goto yy14;
	default:	goto yy3;
	}
yy3:
#line 52 "parsers/msh.c++.re2c"
	{ return LEX_UNKNOWN_TOKEN; }
#line 59 "parsers/msh.c++"
yy4:
	++pos;
#line 50 "parsers/msh.c++.re2c"
	{ return LEX_EOL; }
#line 64 "parsers/msh.c++"
yy6:
	++pos;
	yych = *pos;
	goto yy10;
yy7:
#line 51 "parsers/msh.c++.re2c"
	{ goto std;}
#line 72 "parsers/msh.c++"
yy8:
	yych = *++pos;
	goto yy3;
yy9:
	++pos;
	if (lim <= pos) YYFILL(1);
	yych = *pos;
yy10:
	switch (yych) {
	case ' ':	goto yy9;
	default:	goto yy7;
	}
yy11:
	yych = *++pos;
	switch (yych) {
	case 'l':	goto yy49;
	default:	goto yy12;
	}
yy12:
	pos = marker;
	goto yy3;
yy13:
	yych = *++pos;
	switch (yych) {
	case 'o':	goto yy39;
	default:	goto yy12;
	}
yy14:
	yych = *++pos;
	switch (yych) {
	case 'h':	goto yy26;
	default:	goto yy12;
	}
yy15:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy16;
	default:	goto yy12;
	}
yy16:
	yych = *++pos;
	switch (yych) {
	case 's':	goto yy17;
	default:	goto yy12;
	}
yy17:
	yych = *++pos;
	switch (yych) {
	case 'h':	goto yy18;
	default:	goto yy12;
	}
yy18:
	yych = *++pos;
	switch (yych) {
	case 'F':	goto yy19;
	default:	goto yy12;
	}
yy19:
	yych = *++pos;
	switch (yych) {
	case 'o':	goto yy20;
	default:	goto yy12;
	}
yy20:
	yych = *++pos;
	switch (yych) {
	case 'r':	goto yy21;
	default:	goto yy12;
	}
yy21:
	yych = *++pos;
	switch (yych) {
	case 'm':	goto yy22;
	default:	goto yy12;
	}
yy22:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy23;
	default:	goto yy12;
	}
yy23:
	yych = *++pos;
	switch (yych) {
	case 't':	goto yy24;
	default:	goto yy12;
	}
yy24:
	++pos;
#line 43 "parsers/msh.c++.re2c"
	{ lex_state = 1; return LEX_OPEN_MESH_FORMAT;	}
#line 164 "parsers/msh.c++"
yy26:
	yych = *++pos;
	switch (yych) {
	case 'y':	goto yy27;
	default:	goto yy12;
	}
yy27:
	yych = *++pos;
	switch (yych) {
	case 's':	goto yy28;
	default:	goto yy12;
	}
yy28:
	yych = *++pos;
	switch (yych) {
	case 'i':	goto yy29;
	default:	goto yy12;
	}
yy29:
	yych = *++pos;
	switch (yych) {
	case 'c':	goto yy30;
	default:	goto yy12;
	}
yy30:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy31;
	default:	goto yy12;
	}
yy31:
	yych = *++pos;
	switch (yych) {
	case 'l':	goto yy32;
	default:	goto yy12;
	}
yy32:
	yych = *++pos;
	switch (yych) {
	case 'N':	goto yy33;
	default:	goto yy12;
	}
yy33:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy34;
	default:	goto yy12;
	}
yy34:
	yych = *++pos;
	switch (yych) {
	case 'm':	goto yy35;
	default:	goto yy12;
	}
yy35:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy36;
	default:	goto yy12;
	}
yy36:
	yych = *++pos;
	switch (yych) {
	case 's':	goto yy37;
	default:	goto yy12;
	}
yy37:
	++pos;
#line 46 "parsers/msh.c++.re2c"
	{ return LEX_OPEN_PHYSICAL_NAMES;	}
#line 235 "parsers/msh.c++"
yy39:
	yych = *++pos;
	switch (yych) {
	case 'd':	goto yy40;
	default:	goto yy12;
	}
yy40:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy41;
	default:	goto yy12;
	}
yy41:
	yych = *++pos;
	switch (yych) {
	case 'D':	goto yy42;
	case 's':	goto yy43;
	default:	goto yy12;
	}
yy42:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy45;
	default:	goto yy12;
	}
yy43:
	++pos;
#line 44 "parsers/msh.c++.re2c"
	{ lex_state = 2; return LEX_OPEN_NODES;	}
#line 265 "parsers/msh.c++"
yy45:
	yych = *++pos;
	switch (yych) {
	case 't':	goto yy46;
	default:	goto yy12;
	}
yy46:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy47;
	default:	goto yy12;
	}
yy47:
	++pos;
#line 47 "parsers/msh.c++.re2c"
	{ return LEX_OPEN_NODE_DATA;	}
#line 282 "parsers/msh.c++"
yy49:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy50;
	default:	goto yy12;
	}
yy50:
	yych = *++pos;
	switch (yych) {
	case 'm':	goto yy51;
	default:	goto yy12;
	}
yy51:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy52;
	default:	goto yy12;
	}
yy52:
	yych = *++pos;
	switch (yych) {
	case 'n':	goto yy53;
	default:	goto yy12;
	}
yy53:
	yych = *++pos;
	switch (yych) {
	case 't':	goto yy54;
	default:	goto yy12;
	}
yy54:
	yych = *++pos;
	switch (yych) {
	case 'D':	goto yy57;
	case 'N':	goto yy58;
	case 's':	goto yy55;
	default:	goto yy12;
	}
yy55:
	++pos;
#line 45 "parsers/msh.c++.re2c"
	{ lex_state = 4; return LEX_OPEN_ELEMENTS;	}
#line 325 "parsers/msh.c++"
yy57:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy67;
	default:	goto yy12;
	}
yy58:
	yych = *++pos;
	switch (yych) {
	case 'o':	goto yy59;
	default:	goto yy12;
	}
yy59:
	yych = *++pos;
	switch (yych) {
	case 'd':	goto yy60;
	default:	goto yy12;
	}
yy60:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy61;
	default:	goto yy12;
	}
yy61:
	yych = *++pos;
	switch (yych) {
	case 'D':	goto yy62;
	default:	goto yy12;
	}
yy62:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy63;
	default:	goto yy12;
	}
yy63:
	yych = *++pos;
	switch (yych) {
	case 't':	goto yy64;
	default:	goto yy12;
	}
yy64:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy65;
	default:	goto yy12;
	}
yy65:
	++pos;
#line 49 "parsers/msh.c++.re2c"
	{ return LEX_OPEN_ELEMENT_NODE_DATA;	}
#line 378 "parsers/msh.c++"
yy67:
	yych = *++pos;
	switch (yych) {
	case 't':	goto yy68;
	default:	goto yy12;
	}
yy68:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy69;
	default:	goto yy12;
	}
yy69:
	++pos;
#line 48 "parsers/msh.c++.re2c"
	{ return LEX_OPEN_ELEMENT_DATA;	}
#line 395 "parsers/msh.c++"
}
#line 53 "parsers/msh.c++.re2c"

		}
		break;

		case 1:	// get parser version as a lexer token
		{
	
#line 405 "parsers/msh.c++"
{
	char yych;
	unsigned int yyaccept = 0;
	if ((lim - pos) < 14) YYFILL(14);
	yych = *pos;
	switch (yych) {
	case '\n':	goto yy80;
	case ' ':	goto yy82;
	case '$':	goto yy78;
	case '0':	goto yy75;
	case '1':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy77;
	case '2':	goto yy73;
	default:	goto yy84;
	}
yy73:
	yyaccept = 0;
	yych = *(marker = ++pos);
	switch (yych) {
	case '.':	goto yy102;
	default:	goto yy74;
	}
yy74:
#line 62 "parsers/msh.c++.re2c"
	{ return LEX_DATA_SIZE;	}
#line 437 "parsers/msh.c++"
yy75:
	++pos;
#line 61 "parsers/msh.c++.re2c"
	{ return LEX_FILE_TYPE;	}
#line 442 "parsers/msh.c++"
yy77:
	yych = *++pos;
	goto yy74;
yy78:
	yyaccept = 1;
	yych = *(marker = ++pos);
	switch (yych) {
	case 'E':	goto yy87;
	default:	goto yy79;
	}
yy79:
#line 66 "parsers/msh.c++.re2c"
	{ return LEX_UNKNOWN_TOKEN; }
#line 456 "parsers/msh.c++"
yy80:
	++pos;
#line 64 "parsers/msh.c++.re2c"
	{ return LEX_EOL; }
#line 461 "parsers/msh.c++"
yy82:
	++pos;
	yych = *pos;
	goto yy86;
yy83:
#line 65 "parsers/msh.c++.re2c"
	{ goto std;	}
#line 469 "parsers/msh.c++"
yy84:
	yych = *++pos;
	goto yy79;
yy85:
	++pos;
	if (lim <= pos) YYFILL(1);
	yych = *pos;
yy86:
	switch (yych) {
	case ' ':	goto yy85;
	default:	goto yy83;
	}
yy87:
	yych = *++pos;
	switch (yych) {
	case 'n':	goto yy89;
	default:	goto yy88;
	}
yy88:
	pos = marker;
	switch (yyaccept) {
	case 0: 	goto yy74;
	case 1: 	goto yy79;
	}
yy89:
	yych = *++pos;
	switch (yych) {
	case 'd':	goto yy90;
	default:	goto yy88;
	}
yy90:
	yych = *++pos;
	switch (yych) {
	case 'M':	goto yy91;
	default:	goto yy88;
	}
yy91:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy92;
	default:	goto yy88;
	}
yy92:
	yych = *++pos;
	switch (yych) {
	case 's':	goto yy93;
	default:	goto yy88;
	}
yy93:
	yych = *++pos;
	switch (yych) {
	case 'h':	goto yy94;
	default:	goto yy88;
	}
yy94:
	yych = *++pos;
	switch (yych) {
	case 'F':	goto yy95;
	default:	goto yy88;
	}
yy95:
	yych = *++pos;
	switch (yych) {
	case 'o':	goto yy96;
	default:	goto yy88;
	}
yy96:
	yych = *++pos;
	switch (yych) {
	case 'r':	goto yy97;
	default:	goto yy88;
	}
yy97:
	yych = *++pos;
	switch (yych) {
	case 'm':	goto yy98;
	default:	goto yy88;
	}
yy98:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy99;
	default:	goto yy88;
	}
yy99:
	yych = *++pos;
	switch (yych) {
	case 't':	goto yy100;
	default:	goto yy88;
	}
yy100:
	++pos;
#line 63 "parsers/msh.c++.re2c"
	{ lex_state = 0;	return LEX_CLOSE_MESH_FORMAT; }
#line 564 "parsers/msh.c++"
yy102:
	yych = *++pos;
	switch (yych) {
	case '1':	goto yy103;
	default:	goto yy88;
	}
yy103:
	++pos;
#line 60 "parsers/msh.c++.re2c"
	{ return LEX_VERSION_2_1;	}
#line 575 "parsers/msh.c++"
}
#line 67 "parsers/msh.c++.re2c"

		}
		break;

		case 2:	// parse nodes section: index
		{
	
#line 585 "parsers/msh.c++"
{
	char yych;
	if ((lim - pos) < 9) YYFILL(9);
	yych = *pos;
	switch (yych) {
	case '\n':	goto yy112;
	case ' ':	goto yy114;
	case '$':	goto yy110;
	case '0':	goto yy107;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy109;
	default:	goto yy116;
	}
yy107:
	++pos;
yy108:
#line 74 "parsers/msh.c++.re2c"
	{ lex_state = 3; setIndex(); return LEX_INDEX; }
#line 611 "parsers/msh.c++"
yy109:
	yych = *++pos;
	goto yy130;
yy110:
	yych = *(marker = ++pos);
	switch (yych) {
	case 'E':	goto yy119;
	default:	goto yy111;
	}
yy111:
#line 78 "parsers/msh.c++.re2c"
	{ return LEX_UNKNOWN_TOKEN; }
#line 624 "parsers/msh.c++"
yy112:
	++pos;
#line 76 "parsers/msh.c++.re2c"
	{ return LEX_EOL; }
#line 629 "parsers/msh.c++"
yy114:
	++pos;
	yych = *pos;
	goto yy118;
yy115:
#line 77 "parsers/msh.c++.re2c"
	{ goto std;	}
#line 637 "parsers/msh.c++"
yy116:
	yych = *++pos;
	goto yy111;
yy117:
	++pos;
	if (lim <= pos) YYFILL(1);
	yych = *pos;
yy118:
	switch (yych) {
	case ' ':	goto yy117;
	default:	goto yy115;
	}
yy119:
	yych = *++pos;
	switch (yych) {
	case 'n':	goto yy121;
	default:	goto yy120;
	}
yy120:
	pos = marker;
	goto yy111;
yy121:
	yych = *++pos;
	switch (yych) {
	case 'd':	goto yy122;
	default:	goto yy120;
	}
yy122:
	yych = *++pos;
	switch (yych) {
	case 'N':	goto yy123;
	default:	goto yy120;
	}
yy123:
	yych = *++pos;
	switch (yych) {
	case 'o':	goto yy124;
	default:	goto yy120;
	}
yy124:
	yych = *++pos;
	switch (yych) {
	case 'd':	goto yy125;
	default:	goto yy120;
	}
yy125:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy126;
	default:	goto yy120;
	}
yy126:
	yych = *++pos;
	switch (yych) {
	case 's':	goto yy127;
	default:	goto yy120;
	}
yy127:
	++pos;
#line 75 "parsers/msh.c++.re2c"
	{ lex_state = 0;	return LEX_CLOSE_NODES; }
#line 699 "parsers/msh.c++"
yy129:
	++pos;
	if (lim <= pos) YYFILL(1);
	yych = *pos;
yy130:
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy129;
	default:	goto yy108;
	}
}
#line 79 "parsers/msh.c++.re2c"

		}
		break;

		case 3:	// parse nodes section: coordinates
		{
	
#line 727 "parsers/msh.c++"
{
	char yych;
	if ((lim - pos) < 4) YYFILL(4);
	yych = *pos;
	switch (yych) {
	case '\n':	goto yy138;
	case ' ':	goto yy140;
	case '-':	goto yy133;
	case '0':	goto yy135;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy137;
	default:	goto yy142;
	}
yy133:
	++pos;
	switch ((yych = *pos)) {
	case '0':	goto yy155;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy145;
	default:	goto yy134;
	}
yy134:
#line 89 "parsers/msh.c++.re2c"
	{ return LEX_UNKNOWN_TOKEN; }
#line 766 "parsers/msh.c++"
yy135:
	yych = *(marker = ++pos);
	switch (yych) {
	case '.':	goto yy147;
	default:	goto yy136;
	}
yy136:
#line 86 "parsers/msh.c++.re2c"
	{ return LEX_NUMBER; }
#line 776 "parsers/msh.c++"
yy137:
	yych = *(marker = ++pos);
	goto yy146;
yy138:
	++pos;
#line 87 "parsers/msh.c++.re2c"
	{ lex_state = 2; return LEX_EOL; }
#line 784 "parsers/msh.c++"
yy140:
	++pos;
	yych = *pos;
	goto yy144;
yy141:
#line 88 "parsers/msh.c++.re2c"
	{ goto std;	}
#line 792 "parsers/msh.c++"
yy142:
	yych = *++pos;
	goto yy134;
yy143:
	++pos;
	if (lim <= pos) YYFILL(1);
	yych = *pos;
yy144:
	switch (yych) {
	case ' ':	goto yy143;
	default:	goto yy141;
	}
yy145:
	marker = ++pos;
	if ((lim - pos) < 2) YYFILL(2);
	yych = *pos;
yy146:
	switch (yych) {
	case '.':	goto yy147;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy145;
	default:	goto yy136;
	}
yy147:
	yych = *++pos;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy149;
	default:	goto yy148;
	}
yy148:
	pos = marker;
	goto yy136;
yy149:
	marker = ++pos;
	if ((lim - pos) < 3) YYFILL(3);
	yych = *pos;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy149;
	case 'E':
	case 'e':	goto yy151;
	default:	goto yy136;
	}
yy151:
	yych = *++pos;
	switch (yych) {
	case '+':
	case '-':	goto yy152;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy153;
	default:	goto yy148;
	}
yy152:
	yych = *++pos;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy153;
	default:	goto yy148;
	}
yy153:
	++pos;
	if (lim <= pos) YYFILL(1);
	yych = *pos;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy153;
	default:	goto yy136;
	}
yy155:
	yych = *(marker = ++pos);
	switch (yych) {
	case '.':	goto yy147;
	default:	goto yy136;
	}
}
#line 90 "parsers/msh.c++.re2c"

		}
		break;

		case 4:	// parse elements section
		{
	
#line 925 "parsers/msh.c++"
{
	char yych;
	if ((lim - pos) < 12) YYFILL(12);
	yych = *pos;
	switch (yych) {
	case '\n':	goto yy163;
	case ' ':	goto yy165;
	case '$':	goto yy161;
	case '0':	goto yy158;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy160;
	default:	goto yy167;
	}
yy158:
	++pos;
yy159:
#line 97 "parsers/msh.c++.re2c"
	{ setIndex(); return LEX_INDEX; }
#line 951 "parsers/msh.c++"
yy160:
	yych = *++pos;
	goto yy184;
yy161:
	yych = *(marker = ++pos);
	switch (yych) {
	case 'E':	goto yy170;
	default:	goto yy162;
	}
yy162:
#line 101 "parsers/msh.c++.re2c"
	{ return LEX_UNKNOWN_TOKEN; }
#line 964 "parsers/msh.c++"
yy163:
	++pos;
#line 99 "parsers/msh.c++.re2c"
	{ return LEX_EOL; }
#line 969 "parsers/msh.c++"
yy165:
	++pos;
	yych = *pos;
	goto yy169;
yy166:
#line 100 "parsers/msh.c++.re2c"
	{ goto std;	}
#line 977 "parsers/msh.c++"
yy167:
	yych = *++pos;
	goto yy162;
yy168:
	++pos;
	if (lim <= pos) YYFILL(1);
	yych = *pos;
yy169:
	switch (yych) {
	case ' ':	goto yy168;
	default:	goto yy166;
	}
yy170:
	yych = *++pos;
	switch (yych) {
	case 'n':	goto yy172;
	default:	goto yy171;
	}
yy171:
	pos = marker;
	goto yy162;
yy172:
	yych = *++pos;
	switch (yych) {
	case 'd':	goto yy173;
	default:	goto yy171;
	}
yy173:
	yych = *++pos;
	switch (yych) {
	case 'E':	goto yy174;
	default:	goto yy171;
	}
yy174:
	yych = *++pos;
	switch (yych) {
	case 'l':	goto yy175;
	default:	goto yy171;
	}
yy175:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy176;
	default:	goto yy171;
	}
yy176:
	yych = *++pos;
	switch (yych) {
	case 'm':	goto yy177;
	default:	goto yy171;
	}
yy177:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy178;
	default:	goto yy171;
	}
yy178:
	yych = *++pos;
	switch (yych) {
	case 'n':	goto yy179;
	default:	goto yy171;
	}
yy179:
	yych = *++pos;
	switch (yych) {
	case 't':	goto yy180;
	default:	goto yy171;
	}
yy180:
	yych = *++pos;
	switch (yych) {
	case 's':	goto yy181;
	default:	goto yy171;
	}
yy181:
	++pos;
#line 98 "parsers/msh.c++.re2c"
	{ lex_state = 0;	return LEX_CLOSE_ELEMENTS; }
#line 1057 "parsers/msh.c++"
yy183:
	++pos;
	if (lim <= pos) YYFILL(1);
	yych = *pos;
yy184:
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy183;
	default:	goto yy159;
	}
}
#line 102 "parsers/msh.c++.re2c"

		}
		break;

		default:
			std::cerr << "Error: default lexer state" << std::endl;
			break;
	}
	return 0;
}


void MshParser::setIndex()
{
	std::string tmp;
	tmp.clear();
	tmp.append(tok,pos-tok); 
	val.number = atoi(tmp.c_str());
}

