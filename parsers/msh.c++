/* Generated by re2c 0.13.5 on Thu Dec  3 01:23:31 2009 */
#line 1 "parsers/msh.c++.re2c"
#include "msh.h++"

#include <iostream>	// for cerr
#include <sstream>

MshParser::MshParser()
{
}


MshParser::~MshParser()
{
}


enum MshParser::Error MshParser::parse(std::string file_name, fem::Model &model)
{
	using namespace std;
	std::vector<size_t> index_vector;
	std::vector<double> number_vector;

	int el_count, el_number;
	int tag_count, tag_number;
	fem::Element::Type type;

	// clean up the model 
	model.clear();

	int state = 0;	// parser state

	file.open(file_name.c_str());
	if(!file.is_open())
		return Parser::P_OPEN_FILE;

	enum MshParser::Lexer token = LEX_OPEN_MESH_FORMAT;
	while( (token = lexer()) != LEX_EOF)
	{
		switch(state)
		{
			case 0:	// starting point
				switch(token)
				{
					case LEX_OPEN_MESH_FORMAT:
						state = 1;	// $MeshFormat, wait for version
						break;

					case LEX_EOL:
						break;

					default:
						return P_INVALID_DOCUMENT;
						break;
				}
				break;

			case 1:	// $MeshFormat, wait for version
				switch(token)
				{
					case LEX_VERSION_2_1:
						state = 2;	// $MeshFormat, wait for file type
						break;

					default:
						return P_INVALID_DOCUMENT;
						break;
				}
				break;

			case 2:// $MeshFormat, wait for file type
				switch(token)
				{
					case LEX_FILE_TYPE:
						state = 3;	//$MeshFormat, wait for data size
						break;

					default:
						return P_INVALID_DOCUMENT;
						break;
				}
				break;

			case 3:	// $MeshFormat, wait for EOL
				switch(token)
				{
					case LEX_EOL:
						state = 4;	// $MeshFormat, wait for fiel closer
						break;

					default:
						return P_INVALID_DOCUMENT;
						break;
				}
				break;

			case 4:	// $MeshFormat, wait for EOL
				switch(token)
				{
					case LEX_CLOSE_MESH_FORMAT:
						state = 5;	// wait for pre-$Nodes EOL
						break;

					default:
						return P_INVALID_DOCUMENT;
						break;
				}
				break;

			case 5:	// wait for pre-$Nodes EOL
				switch(token)
				{
					case LEX_EOL:
						state = 6;	// wait for $Nodes
						break;

					default:
						return P_INVALID_DOCUMENT;
						break;
				}
				break;

			case 6:	// wait for $Nodes
				switch(token)
				{
					case LEX_OPEN_NODES:
						state = 7;	// $Nodes: wait for first EOL
						break;

					default:
						return P_INVALID_DOCUMENT;
						break;
				}
				break;

			case 7:	// $Nodes: wait for first EOL
				switch(token)
				{
					case LEX_EOL:
						state = 8;	// $Nodes: wait for index
						break;

					default:
						return P_INVALID_DOCUMENT;
						break;
				}
				break;

			case 8:	// $Nodes
				switch(token)
				{
					case LEX_INDEX:
						state = 9;	// $Nodes: wait for post-index EOL
						break;

					default:
						return P_INVALID_DOCUMENT;
						break;
				}
				break;

			case 9:	// $Nodes: wait for post-index EOL
				switch(token)
				{
					case LEX_EOL:
						state = 10;	// $Nodes: get node: wait for index
						break;

					default:
						return P_INVALID_DOCUMENT;
						break;
				}
				break;

			case 10:	// $Nodes: get node: wait for index
				index_vector.clear();
				number_vector.clear();
				switch(token)
				{
					case LEX_INDEX:
						index_vector.push_back(val.index);
						state = 11;	// $Nodes: get node: wait for 1 of 3
						break;

					case LEX_CLOSE_NODES:
						state = 15;	// wait for $Elements
						break;

					default:
						return P_INVALID_DOCUMENT;
						break;
				}
				break;

			case 11:	// $Nodes: get node: wait for 1 of 3
				switch(token)
				{
					case LEX_NUMBER:
						number_vector.push_back(val.number);
						state = 12;	// $Nodes: get node: wait for 2 of 3
						break;

					default:
						return P_INVALID_DOCUMENT;
						break;
				}
				break;


			case 12:	// $Nodes: get node: wait for 2 of 3
				switch(token)
				{
					case LEX_NUMBER:
						state = 13;	// $Nodes: get node: wait for 3 of 3
						break;

					default:
						return P_INVALID_DOCUMENT;
						break;
				}
				break;


			case 13:	// $Nodes: get node: wait for 3 of 3
				switch(token)
				{
					case LEX_NUMBER:
						state = 14;	// $Nodes: get node: wait for EOL
						break;

					default:
						return P_INVALID_DOCUMENT;
						break;
				}
				break;

			case 14:	// $Nodes: get node: wait for index
				switch(token)
				{
					case LEX_EOL:
						model.setNode(index_vector[0], number_vector[0], number_vector[1], number_vector[2]);
						state = 10;	// $Nodes: get node: wait for index
						break;

					default:
						return P_INVALID_DOCUMENT;
						break;
				}
				break;

			case 15:	// wait for $Elements
				switch(token)
				{
					case LEX_OPEN_ELEMENTS:
						state = 16;	// post-$Elements EOL
						break;

					default:
						return P_INVALID_DOCUMENT;
						break;
				}
				break;

			case 16:	// post-$Elements EOL
				switch(token)
				{
					case LEX_INDEX:
						state = 17;	// $Elements: post-index EOL
						break;

					default:
						return P_INVALID_DOCUMENT;
						break;
				}
				break;

			case 17:	// $Elements: post-index EOL
				switch(token)
				{
					case LEX_EOL:
						state = 18;	// $Elements: element index
						break;

					case LEX_CLOSE_ELEMENTS:
						state = 24;
						break;

					default:
						return P_INVALID_DOCUMENT;
						break;
				}
				break;

			case 18:	// $Elements: element index
				switch(token)
				{
					case LEX_INDEX:
						state = 19;	// $Elements: element type
						break;

					default:
						return P_INVALID_DOCUMENT;
						break;
				}
				break;

			case 19:	// $Elements: element type
				switch(token)
				{
			case LEX_LINE2:
				el_count = 0, el_number = 2;
				type = fem::Element::FE_LINE2;
				state = 20;	// $Elements LEX_LINE2: wait for tag
				break;

			case LEX_TRIANGLE3:
				el_count = 0, el_number = 3;
				type = fem::Element::FE_TRIANGLE3;
				state = 20;	// $Elements LEX_LINE2: wait for tag
				break;

			/*
			case LEX_QUADRANGLE4:
			//TODO
			break;

			case LEX_TETRAHEDRON4:
			//TODO
			break;

			case LEX_HEXAHEDRON8:
			//TODO
			break;

			case LEX_PRISM6:
			//TODO
			break;

			case LEX_PYRAMID5:
			//TODO
			break;

			case LEX_LINE3:
			//TODO
			break;

			case LEX_TRIANGLE6:
			//TODO
			break;

			case LEX_QUADRANGLE9:
			//TODO
			break;

			case LEX_TETRAHEDRON10:
			//TODO
			break;

			case LEX_HEXAHEDRON27:
			//TODO
			break;

			case LEX_PRISM18:
			//TODO
			break;

			case LEX_PYRAMID14:
			//TODO
			break;

			case LEX_POINT:
			//TODO
			break;

			case LEX_QUADRANGLE8:
			//TODO
			break;

			case LEX_HEXAHEDRON20:
			//TODO
			break;

			case LEX_PRISM15:
			//TODO
			break;

			case LEX_PYRAMID13:
			//TODO
			break;

			case LEX_ITRIANGLE9:
			//TODO
			break;

			case LEX_TRIANGLE10:
			//TODO
			break;

			case LEX_ITRIANGLE12:
			//TODO
			break;

			case LEX_TRIANGLE15:
			//TODO
			break;

			case LEX_ITRIANGLE15:
			//TODO
			break;

			case LEX_TRIANGLE21:
			//TODO
			break;

			case LEX_EDGE4:
			//TODO
			break;

			case LEX_EDGE5:
			//TODO
			break;

			case LEX_EDGE6:
			//TODO
			break;

			case LEX_TETRAHEDRON20:
			//TODO
			break;

			case LEX_TETRAHEDRON35:
			//TODO
			break;

			case LEX_TETRAHEDRON56:
			//TODO
			break;
			*/

					default:
						return P_INVALID_DOCUMENT;
						break;
				}
				break;

			case 20:	// $Elements: get tag count
				switch(token)
				{
					case LEX_TOKEN_0:
						tag_count = 0, tag_number = 0;
						state = 22;	// $Elements: get nodes
						break;

					case LEX_TOKEN_1:
						tag_count = 0, tag_number = 1;
						state = 21;
						break;

					case LEX_TOKEN_2:
						tag_count = 0, tag_number = 2;
						state = 21;
						break;

					case LEX_TOKEN_3:
						tag_count = 0, tag_number = 3;
						state = 21;
						break;

					default:
						return P_INVALID_DOCUMENT;
						break;
				}
				break;

			case 21:	// $Elements: get tag indexes
				switch(token)
				{
					case LEX_INDEX:
						if(tag_count < tag_number)
						{
							tag_count++;
						}
						else
						{
							// move to greener pastures
							state = 22;	// $Elements: get nodes
						}
						break;

					default:
						return P_INVALID_DOCUMENT;
						break;
				}
				break;

			case 22:
				switch(token)
				{
					case LEX_INDEX:
						if(el_count < el_number)
						{
							index_vector.push_back(val.index);
							el_count++;
						}
						else
						{
							state = 23;	// $Elements: wait for EOL
						}
						break;

					default:
						return P_INVALID_DOCUMENT;
						break;
				}
				break;

			case 23:
				switch(token)
				{
					case LEX_EOL:
						model.pushElement(type, index_vector);
						index_vector.clear();
						state = 17;	// $Element: post-index EOL
						break;

					default:
						return P_INVALID_DOCUMENT;
						break;
				}
				break;

			case 24:	// post-$Elements
				switch(token)
				{
					case LEX_EOL:
						state = 99;	// wait until EOF
						break;

					default:
						return P_INVALID_DOCUMENT;
						break;
				}
				break;

			case 99:
				switch(token)
				{
					case LEX_EOL:
						state = 99;	// wait until EOF
						break;

					default:
						return P_INVALID_DOCUMENT;
						break;
				}
				break;

			default:
				return P_UNKNOWN;	// this state shouldn't be here
				break;
		}
	}

	// exit
	file.close();
	return MshParser::P_OK;
}


enum MshParser::Lexer MshParser::lexer()
{
	tok = pos;
std:
	switch(lex_state)
	{
		case 0:
		{
	#define YYFILL(n) { if(file.eof()){ if(tok == lim) return LEX_EOF; } else fill(); }
	
#line 581 "parsers/msh.c++"
{
	char yych;

	if ((lim - pos) < 16) YYFILL(16);
	yych = *pos;
	switch (yych) {
	case '\n':	goto yy4;
	case ' ':	goto yy6;
	case '$':	goto yy2;
	default:	goto yy8;
	}
yy2:
	yych = *(marker = ++pos);
	switch (yych) {
	case 'E':	goto yy11;
	case 'M':	goto yy15;
	case 'N':	goto yy13;
	case 'P':	goto yy14;
	default:	goto yy3;
	}
yy3:
#line 599 "parsers/msh.c++.re2c"
	{ return LEX_UNKNOWN_TOKEN; }
#line 605 "parsers/msh.c++"
yy4:
	++pos;
#line 597 "parsers/msh.c++.re2c"
	{ return LEX_EOL; }
#line 610 "parsers/msh.c++"
yy6:
	++pos;
	yych = *pos;
	goto yy10;
yy7:
#line 598 "parsers/msh.c++.re2c"
	{ goto std;}
#line 618 "parsers/msh.c++"
yy8:
	yych = *++pos;
	goto yy3;
yy9:
	++pos;
	if (lim <= pos) YYFILL(1);
	yych = *pos;
yy10:
	switch (yych) {
	case ' ':	goto yy9;
	default:	goto yy7;
	}
yy11:
	yych = *++pos;
	switch (yych) {
	case 'l':	goto yy49;
	default:	goto yy12;
	}
yy12:
	pos = marker;
	goto yy3;
yy13:
	yych = *++pos;
	switch (yych) {
	case 'o':	goto yy39;
	default:	goto yy12;
	}
yy14:
	yych = *++pos;
	switch (yych) {
	case 'h':	goto yy26;
	default:	goto yy12;
	}
yy15:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy16;
	default:	goto yy12;
	}
yy16:
	yych = *++pos;
	switch (yych) {
	case 's':	goto yy17;
	default:	goto yy12;
	}
yy17:
	yych = *++pos;
	switch (yych) {
	case 'h':	goto yy18;
	default:	goto yy12;
	}
yy18:
	yych = *++pos;
	switch (yych) {
	case 'F':	goto yy19;
	default:	goto yy12;
	}
yy19:
	yych = *++pos;
	switch (yych) {
	case 'o':	goto yy20;
	default:	goto yy12;
	}
yy20:
	yych = *++pos;
	switch (yych) {
	case 'r':	goto yy21;
	default:	goto yy12;
	}
yy21:
	yych = *++pos;
	switch (yych) {
	case 'm':	goto yy22;
	default:	goto yy12;
	}
yy22:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy23;
	default:	goto yy12;
	}
yy23:
	yych = *++pos;
	switch (yych) {
	case 't':	goto yy24;
	default:	goto yy12;
	}
yy24:
	++pos;
#line 590 "parsers/msh.c++.re2c"
	{ lex_state = 1; return LEX_OPEN_MESH_FORMAT;	}
#line 710 "parsers/msh.c++"
yy26:
	yych = *++pos;
	switch (yych) {
	case 'y':	goto yy27;
	default:	goto yy12;
	}
yy27:
	yych = *++pos;
	switch (yych) {
	case 's':	goto yy28;
	default:	goto yy12;
	}
yy28:
	yych = *++pos;
	switch (yych) {
	case 'i':	goto yy29;
	default:	goto yy12;
	}
yy29:
	yych = *++pos;
	switch (yych) {
	case 'c':	goto yy30;
	default:	goto yy12;
	}
yy30:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy31;
	default:	goto yy12;
	}
yy31:
	yych = *++pos;
	switch (yych) {
	case 'l':	goto yy32;
	default:	goto yy12;
	}
yy32:
	yych = *++pos;
	switch (yych) {
	case 'N':	goto yy33;
	default:	goto yy12;
	}
yy33:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy34;
	default:	goto yy12;
	}
yy34:
	yych = *++pos;
	switch (yych) {
	case 'm':	goto yy35;
	default:	goto yy12;
	}
yy35:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy36;
	default:	goto yy12;
	}
yy36:
	yych = *++pos;
	switch (yych) {
	case 's':	goto yy37;
	default:	goto yy12;
	}
yy37:
	++pos;
#line 593 "parsers/msh.c++.re2c"
	{ return LEX_OPEN_PHYSICAL_NAMES;	}
#line 781 "parsers/msh.c++"
yy39:
	yych = *++pos;
	switch (yych) {
	case 'd':	goto yy40;
	default:	goto yy12;
	}
yy40:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy41;
	default:	goto yy12;
	}
yy41:
	yych = *++pos;
	switch (yych) {
	case 'D':	goto yy42;
	case 's':	goto yy43;
	default:	goto yy12;
	}
yy42:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy45;
	default:	goto yy12;
	}
yy43:
	++pos;
#line 591 "parsers/msh.c++.re2c"
	{ lex_state = 2; return LEX_OPEN_NODES;	}
#line 811 "parsers/msh.c++"
yy45:
	yych = *++pos;
	switch (yych) {
	case 't':	goto yy46;
	default:	goto yy12;
	}
yy46:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy47;
	default:	goto yy12;
	}
yy47:
	++pos;
#line 594 "parsers/msh.c++.re2c"
	{ return LEX_OPEN_NODE_DATA;	}
#line 828 "parsers/msh.c++"
yy49:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy50;
	default:	goto yy12;
	}
yy50:
	yych = *++pos;
	switch (yych) {
	case 'm':	goto yy51;
	default:	goto yy12;
	}
yy51:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy52;
	default:	goto yy12;
	}
yy52:
	yych = *++pos;
	switch (yych) {
	case 'n':	goto yy53;
	default:	goto yy12;
	}
yy53:
	yych = *++pos;
	switch (yych) {
	case 't':	goto yy54;
	default:	goto yy12;
	}
yy54:
	yych = *++pos;
	switch (yych) {
	case 'D':	goto yy57;
	case 'N':	goto yy58;
	case 's':	goto yy55;
	default:	goto yy12;
	}
yy55:
	++pos;
#line 592 "parsers/msh.c++.re2c"
	{ lex_state = 4; return LEX_OPEN_ELEMENTS;	}
#line 871 "parsers/msh.c++"
yy57:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy67;
	default:	goto yy12;
	}
yy58:
	yych = *++pos;
	switch (yych) {
	case 'o':	goto yy59;
	default:	goto yy12;
	}
yy59:
	yych = *++pos;
	switch (yych) {
	case 'd':	goto yy60;
	default:	goto yy12;
	}
yy60:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy61;
	default:	goto yy12;
	}
yy61:
	yych = *++pos;
	switch (yych) {
	case 'D':	goto yy62;
	default:	goto yy12;
	}
yy62:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy63;
	default:	goto yy12;
	}
yy63:
	yych = *++pos;
	switch (yych) {
	case 't':	goto yy64;
	default:	goto yy12;
	}
yy64:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy65;
	default:	goto yy12;
	}
yy65:
	++pos;
#line 596 "parsers/msh.c++.re2c"
	{ return LEX_OPEN_ELEMENT_NODE_DATA;	}
#line 924 "parsers/msh.c++"
yy67:
	yych = *++pos;
	switch (yych) {
	case 't':	goto yy68;
	default:	goto yy12;
	}
yy68:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy69;
	default:	goto yy12;
	}
yy69:
	++pos;
#line 595 "parsers/msh.c++.re2c"
	{ return LEX_OPEN_ELEMENT_DATA;	}
#line 941 "parsers/msh.c++"
}
#line 600 "parsers/msh.c++.re2c"

		}
		break;

		case 1:	// get parser version as a lexer token
		{
	
#line 951 "parsers/msh.c++"
{
	char yych;
	unsigned int yyaccept = 0;
	if ((lim - pos) < 14) YYFILL(14);
	yych = *pos;
	switch (yych) {
	case '\n':	goto yy80;
	case ' ':	goto yy82;
	case '$':	goto yy78;
	case '0':	goto yy75;
	case '1':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy77;
	case '2':	goto yy73;
	default:	goto yy84;
	}
yy73:
	yyaccept = 0;
	yych = *(marker = ++pos);
	switch (yych) {
	case '.':	goto yy102;
	default:	goto yy74;
	}
yy74:
#line 609 "parsers/msh.c++.re2c"
	{ return LEX_DATA_SIZE;	}
#line 983 "parsers/msh.c++"
yy75:
	++pos;
#line 608 "parsers/msh.c++.re2c"
	{ return LEX_FILE_TYPE;	}
#line 988 "parsers/msh.c++"
yy77:
	yych = *++pos;
	goto yy74;
yy78:
	yyaccept = 1;
	yych = *(marker = ++pos);
	switch (yych) {
	case 'E':	goto yy87;
	default:	goto yy79;
	}
yy79:
#line 613 "parsers/msh.c++.re2c"
	{ return LEX_UNKNOWN_TOKEN; }
#line 1002 "parsers/msh.c++"
yy80:
	++pos;
#line 611 "parsers/msh.c++.re2c"
	{ return LEX_EOL; }
#line 1007 "parsers/msh.c++"
yy82:
	++pos;
	yych = *pos;
	goto yy86;
yy83:
#line 612 "parsers/msh.c++.re2c"
	{ goto std;	}
#line 1015 "parsers/msh.c++"
yy84:
	yych = *++pos;
	goto yy79;
yy85:
	++pos;
	if (lim <= pos) YYFILL(1);
	yych = *pos;
yy86:
	switch (yych) {
	case ' ':	goto yy85;
	default:	goto yy83;
	}
yy87:
	yych = *++pos;
	switch (yych) {
	case 'n':	goto yy89;
	default:	goto yy88;
	}
yy88:
	pos = marker;
	switch (yyaccept) {
	case 0: 	goto yy74;
	case 1: 	goto yy79;
	}
yy89:
	yych = *++pos;
	switch (yych) {
	case 'd':	goto yy90;
	default:	goto yy88;
	}
yy90:
	yych = *++pos;
	switch (yych) {
	case 'M':	goto yy91;
	default:	goto yy88;
	}
yy91:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy92;
	default:	goto yy88;
	}
yy92:
	yych = *++pos;
	switch (yych) {
	case 's':	goto yy93;
	default:	goto yy88;
	}
yy93:
	yych = *++pos;
	switch (yych) {
	case 'h':	goto yy94;
	default:	goto yy88;
	}
yy94:
	yych = *++pos;
	switch (yych) {
	case 'F':	goto yy95;
	default:	goto yy88;
	}
yy95:
	yych = *++pos;
	switch (yych) {
	case 'o':	goto yy96;
	default:	goto yy88;
	}
yy96:
	yych = *++pos;
	switch (yych) {
	case 'r':	goto yy97;
	default:	goto yy88;
	}
yy97:
	yych = *++pos;
	switch (yych) {
	case 'm':	goto yy98;
	default:	goto yy88;
	}
yy98:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy99;
	default:	goto yy88;
	}
yy99:
	yych = *++pos;
	switch (yych) {
	case 't':	goto yy100;
	default:	goto yy88;
	}
yy100:
	++pos;
#line 610 "parsers/msh.c++.re2c"
	{ lex_state = 0;	return LEX_CLOSE_MESH_FORMAT; }
#line 1110 "parsers/msh.c++"
yy102:
	yych = *++pos;
	switch (yych) {
	case '1':	goto yy103;
	default:	goto yy88;
	}
yy103:
	++pos;
#line 607 "parsers/msh.c++.re2c"
	{ return LEX_VERSION_2_1;	}
#line 1121 "parsers/msh.c++"
}
#line 614 "parsers/msh.c++.re2c"

		}
		break;

		case 2:	// parse nodes section: index
		{
	
#line 1131 "parsers/msh.c++"
{
	char yych;
	if ((lim - pos) < 9) YYFILL(9);
	yych = *pos;
	switch (yych) {
	case '\n':	goto yy112;
	case ' ':	goto yy114;
	case '$':	goto yy110;
	case '0':	goto yy107;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy109;
	default:	goto yy116;
	}
yy107:
	++pos;
yy108:
#line 621 "parsers/msh.c++.re2c"
	{ lex_state = 3; setIndex(); return LEX_INDEX; }
#line 1157 "parsers/msh.c++"
yy109:
	yych = *++pos;
	goto yy130;
yy110:
	yych = *(marker = ++pos);
	switch (yych) {
	case 'E':	goto yy119;
	default:	goto yy111;
	}
yy111:
#line 625 "parsers/msh.c++.re2c"
	{ return LEX_UNKNOWN_TOKEN; }
#line 1170 "parsers/msh.c++"
yy112:
	++pos;
#line 623 "parsers/msh.c++.re2c"
	{ return LEX_EOL; }
#line 1175 "parsers/msh.c++"
yy114:
	++pos;
	yych = *pos;
	goto yy118;
yy115:
#line 624 "parsers/msh.c++.re2c"
	{ goto std;	}
#line 1183 "parsers/msh.c++"
yy116:
	yych = *++pos;
	goto yy111;
yy117:
	++pos;
	if (lim <= pos) YYFILL(1);
	yych = *pos;
yy118:
	switch (yych) {
	case ' ':	goto yy117;
	default:	goto yy115;
	}
yy119:
	yych = *++pos;
	switch (yych) {
	case 'n':	goto yy121;
	default:	goto yy120;
	}
yy120:
	pos = marker;
	goto yy111;
yy121:
	yych = *++pos;
	switch (yych) {
	case 'd':	goto yy122;
	default:	goto yy120;
	}
yy122:
	yych = *++pos;
	switch (yych) {
	case 'N':	goto yy123;
	default:	goto yy120;
	}
yy123:
	yych = *++pos;
	switch (yych) {
	case 'o':	goto yy124;
	default:	goto yy120;
	}
yy124:
	yych = *++pos;
	switch (yych) {
	case 'd':	goto yy125;
	default:	goto yy120;
	}
yy125:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy126;
	default:	goto yy120;
	}
yy126:
	yych = *++pos;
	switch (yych) {
	case 's':	goto yy127;
	default:	goto yy120;
	}
yy127:
	++pos;
#line 622 "parsers/msh.c++.re2c"
	{ lex_state = 0;	return LEX_CLOSE_NODES; }
#line 1245 "parsers/msh.c++"
yy129:
	++pos;
	if (lim <= pos) YYFILL(1);
	yych = *pos;
yy130:
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy129;
	default:	goto yy108;
	}
}
#line 626 "parsers/msh.c++.re2c"

		}
		break;

		case 3:	// parse nodes section: coordinates
		{
	
#line 1273 "parsers/msh.c++"
{
	char yych;
	if ((lim - pos) < 4) YYFILL(4);
	yych = *pos;
	switch (yych) {
	case '\n':	goto yy138;
	case ' ':	goto yy140;
	case '-':	goto yy133;
	case '0':	goto yy135;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy137;
	default:	goto yy142;
	}
yy133:
	++pos;
	switch ((yych = *pos)) {
	case '0':	goto yy155;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy145;
	default:	goto yy134;
	}
yy134:
#line 636 "parsers/msh.c++.re2c"
	{ return LEX_UNKNOWN_TOKEN; }
#line 1312 "parsers/msh.c++"
yy135:
	yych = *(marker = ++pos);
	switch (yych) {
	case '.':	goto yy147;
	default:	goto yy136;
	}
yy136:
#line 633 "parsers/msh.c++.re2c"
	{ return LEX_NUMBER; }
#line 1322 "parsers/msh.c++"
yy137:
	yych = *(marker = ++pos);
	goto yy146;
yy138:
	++pos;
#line 634 "parsers/msh.c++.re2c"
	{ lex_state = 2; return LEX_EOL; }
#line 1330 "parsers/msh.c++"
yy140:
	++pos;
	yych = *pos;
	goto yy144;
yy141:
#line 635 "parsers/msh.c++.re2c"
	{ goto std;	}
#line 1338 "parsers/msh.c++"
yy142:
	yych = *++pos;
	goto yy134;
yy143:
	++pos;
	if (lim <= pos) YYFILL(1);
	yych = *pos;
yy144:
	switch (yych) {
	case ' ':	goto yy143;
	default:	goto yy141;
	}
yy145:
	marker = ++pos;
	if ((lim - pos) < 2) YYFILL(2);
	yych = *pos;
yy146:
	switch (yych) {
	case '.':	goto yy147;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy145;
	default:	goto yy136;
	}
yy147:
	yych = *++pos;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy149;
	default:	goto yy148;
	}
yy148:
	pos = marker;
	goto yy136;
yy149:
	marker = ++pos;
	if ((lim - pos) < 3) YYFILL(3);
	yych = *pos;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy149;
	case 'E':
	case 'e':	goto yy151;
	default:	goto yy136;
	}
yy151:
	yych = *++pos;
	switch (yych) {
	case '+':
	case '-':	goto yy152;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy153;
	default:	goto yy148;
	}
yy152:
	yych = *++pos;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy153;
	default:	goto yy148;
	}
yy153:
	++pos;
	if (lim <= pos) YYFILL(1);
	yych = *pos;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy153;
	default:	goto yy136;
	}
yy155:
	yych = *(marker = ++pos);
	switch (yych) {
	case '.':	goto yy147;
	default:	goto yy136;
	}
}
#line 637 "parsers/msh.c++.re2c"

		}
		break;

		case 4:	// parse elements section
		{
	
#line 1471 "parsers/msh.c++"
{
	char yych;
	if ((lim - pos) < 12) YYFILL(12);
	yych = *pos;
	switch (yych) {
	case '\n':	goto yy163;
	case ' ':	goto yy165;
	case '$':	goto yy161;
	case '0':	goto yy158;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy160;
	default:	goto yy167;
	}
yy158:
	++pos;
yy159:
#line 644 "parsers/msh.c++.re2c"
	{ lex_state = 5; setIndex(); return LEX_INDEX; }
#line 1497 "parsers/msh.c++"
yy160:
	yych = *++pos;
	goto yy184;
yy161:
	yych = *(marker = ++pos);
	switch (yych) {
	case 'E':	goto yy170;
	default:	goto yy162;
	}
yy162:
#line 648 "parsers/msh.c++.re2c"
	{ return LEX_UNKNOWN_TOKEN; }
#line 1510 "parsers/msh.c++"
yy163:
	++pos;
#line 646 "parsers/msh.c++.re2c"
	{ return LEX_EOL; }
#line 1515 "parsers/msh.c++"
yy165:
	++pos;
	yych = *pos;
	goto yy169;
yy166:
#line 647 "parsers/msh.c++.re2c"
	{ goto std;	}
#line 1523 "parsers/msh.c++"
yy167:
	yych = *++pos;
	goto yy162;
yy168:
	++pos;
	if (lim <= pos) YYFILL(1);
	yych = *pos;
yy169:
	switch (yych) {
	case ' ':	goto yy168;
	default:	goto yy166;
	}
yy170:
	yych = *++pos;
	switch (yych) {
	case 'n':	goto yy172;
	default:	goto yy171;
	}
yy171:
	pos = marker;
	goto yy162;
yy172:
	yych = *++pos;
	switch (yych) {
	case 'd':	goto yy173;
	default:	goto yy171;
	}
yy173:
	yych = *++pos;
	switch (yych) {
	case 'E':	goto yy174;
	default:	goto yy171;
	}
yy174:
	yych = *++pos;
	switch (yych) {
	case 'l':	goto yy175;
	default:	goto yy171;
	}
yy175:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy176;
	default:	goto yy171;
	}
yy176:
	yych = *++pos;
	switch (yych) {
	case 'm':	goto yy177;
	default:	goto yy171;
	}
yy177:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy178;
	default:	goto yy171;
	}
yy178:
	yych = *++pos;
	switch (yych) {
	case 'n':	goto yy179;
	default:	goto yy171;
	}
yy179:
	yych = *++pos;
	switch (yych) {
	case 't':	goto yy180;
	default:	goto yy171;
	}
yy180:
	yych = *++pos;
	switch (yych) {
	case 's':	goto yy181;
	default:	goto yy171;
	}
yy181:
	++pos;
#line 645 "parsers/msh.c++.re2c"
	{ lex_state = 0;	return LEX_CLOSE_ELEMENTS; }
#line 1603 "parsers/msh.c++"
yy183:
	++pos;
	if (lim <= pos) YYFILL(1);
	yych = *pos;
yy184:
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy183;
	default:	goto yy159;
	}
}
#line 649 "parsers/msh.c++.re2c"

		}
		break;

		case 5:	// parse element type
		{
	
#line 1631 "parsers/msh.c++"
{
	char yych;
	if ((lim - pos) < 2) YYFILL(2);
	yych = *pos;
	switch (yych) {
	case '\n':	goto yy189;
	case ' ':	goto yy191;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy187;
	default:	goto yy193;
	}
yy187:
	++pos;
	yych = *pos;
	goto yy198;
yy188:
#line 656 "parsers/msh.c++.re2c"
	{setIndex();
		lex_state = 6;
		switch(val.index)
		{
		case 1:return LEX_LINE2;
		case 2:return LEX_TRIANGLE3;
		case 3:return LEX_QUADRANGLE4;
		case 4:return LEX_TETRAHEDRON4;
		case 5:return LEX_HEXAHEDRON8;
		case 6:return LEX_PRISM6;
		case 7:return LEX_PYRAMID5;
		case 8:return LEX_LINE3;
		case 9:return LEX_TRIANGLE6;
		case 10:return LEX_QUADRANGLE9;
		case 11:return LEX_TETRAHEDRON10;
		case 12:return LEX_HEXAHEDRON27;
		case 13:return LEX_PRISM18;
		case 14:return LEX_PYRAMID14;
		case 15:return LEX_POINT;
		case 16:return LEX_QUADRANGLE8;
		case 17:return LEX_HEXAHEDRON20;
		case 18:return LEX_PRISM15;
		case 19:return LEX_PYRAMID13;
		case 20:return LEX_ITRIANGLE9;
		case 21:return LEX_TRIANGLE10;
		case 22:return LEX_ITRIANGLE12;
		case 23:return LEX_TRIANGLE15;
		case 24:return LEX_ITRIANGLE15;
		case 25:return LEX_TRIANGLE21;
		case 26:return LEX_EDGE4;
		case 27:return LEX_EDGE5;
		case 28:return LEX_EDGE6;
		case 29:return LEX_TETRAHEDRON20;
		case 30:return LEX_TETRAHEDRON35;
		case 31:return LEX_TETRAHEDRON56;
		default:
			return LEX_UNKNOWN_TOKEN;
		}
		}
#line 1696 "parsers/msh.c++"
yy189:
	++pos;
#line 695 "parsers/msh.c++.re2c"
	{ lex_state = 4; return LEX_EOL; }
#line 1701 "parsers/msh.c++"
yy191:
	++pos;
	yych = *pos;
	goto yy196;
yy192:
#line 696 "parsers/msh.c++.re2c"
	{ goto std;	}
#line 1709 "parsers/msh.c++"
yy193:
	++pos;
#line 697 "parsers/msh.c++.re2c"
	{ return LEX_UNKNOWN_TOKEN; }
#line 1714 "parsers/msh.c++"
yy195:
	++pos;
	if (lim <= pos) YYFILL(1);
	yych = *pos;
yy196:
	switch (yych) {
	case ' ':	goto yy195;
	default:	goto yy192;
	}
yy197:
	++pos;
	if (lim <= pos) YYFILL(1);
	yych = *pos;
yy198:
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy197;
	default:	goto yy188;
	}
}
#line 698 "parsers/msh.c++.re2c"

		}
		break;

	case 6:	// get number of tokens
		{
	
#line 1751 "parsers/msh.c++"
{
	char yych;
	if ((lim - pos) < 2) YYFILL(2);
	yych = *pos;
	switch (yych) {
	case '\n':	goto yy201;
	case ' ':	goto yy202;
	case '0':	goto yy204;
	case '1':	goto yy206;
	case '2':	goto yy208;
	case '3':	goto yy210;
	default:	goto yy212;
	}
yy201:
yy202:
	++pos;
	yych = *pos;
	goto yy215;
yy203:
#line 705 "parsers/msh.c++.re2c"
	{ goto std;	}
#line 1773 "parsers/msh.c++"
yy204:
	++pos;
#line 706 "parsers/msh.c++.re2c"
	{ lex_state = 7; return LEX_TOKEN_0; }
#line 1778 "parsers/msh.c++"
yy206:
	++pos;
#line 707 "parsers/msh.c++.re2c"
	{ lex_state = 7; return LEX_TOKEN_1; }
#line 1783 "parsers/msh.c++"
yy208:
	++pos;
#line 708 "parsers/msh.c++.re2c"
	{ lex_state = 7; return LEX_TOKEN_2; }
#line 1788 "parsers/msh.c++"
yy210:
	++pos;
#line 709 "parsers/msh.c++.re2c"
	{ lex_state = 7; return LEX_TOKEN_3; }
#line 1793 "parsers/msh.c++"
yy212:
	++pos;
#line 710 "parsers/msh.c++.re2c"
	{ return LEX_UNKNOWN_TOKEN; }
#line 1798 "parsers/msh.c++"
yy214:
	++pos;
	if (lim <= pos) YYFILL(1);
	yych = *pos;
yy215:
	switch (yych) {
	case ' ':	goto yy214;
	default:	goto yy203;
	}
}
#line 711 "parsers/msh.c++.re2c"

		}
		break;

	case 7:	// extract indexes until EOL
		{
	
#line 1817 "parsers/msh.c++"
{
	char yych;
	if ((lim - pos) < 2) YYFILL(2);
	yych = *pos;
	switch (yych) {
	case '\n':	goto yy223;
	case ' ':	goto yy221;
	case '0':	goto yy218;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy220;
	default:	goto yy225;
	}
yy218:
	++pos;
yy219:
#line 718 "parsers/msh.c++.re2c"
	{ setIndex(); return LEX_INDEX; }
#line 1842 "parsers/msh.c++"
yy220:
	yych = *++pos;
	goto yy230;
yy221:
	++pos;
	yych = *pos;
	goto yy228;
yy222:
#line 719 "parsers/msh.c++.re2c"
	{ goto std;	}
#line 1853 "parsers/msh.c++"
yy223:
	++pos;
#line 720 "parsers/msh.c++.re2c"
	{ lex_state = 4; return LEX_EOL; }
#line 1858 "parsers/msh.c++"
yy225:
	++pos;
#line 721 "parsers/msh.c++.re2c"
	{ return LEX_UNKNOWN_TOKEN; }
#line 1863 "parsers/msh.c++"
yy227:
	++pos;
	if (lim <= pos) YYFILL(1);
	yych = *pos;
yy228:
	switch (yych) {
	case ' ':	goto yy227;
	default:	goto yy222;
	}
yy229:
	++pos;
	if (lim <= pos) YYFILL(1);
	yych = *pos;
yy230:
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy229;
	default:	goto yy219;
	}
}
#line 722 "parsers/msh.c++.re2c"

		}

		default:
			std::cerr << "Error: default lexer state" << std::endl;
			return LEX_ERROR;
			break;
	}

	// should never be reached
	return LEX_ERROR;
	#undef YYFILL
}


void MshParser::setIndex()
{
	std::string tmp;
	tmp.append(tok,pos-tok); 
	std::istringstream f(tmp);
	f >> val.index;
}

