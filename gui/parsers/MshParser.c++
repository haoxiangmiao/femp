/* Generated by re2c 0.13.5 on Tue Apr 10 16:30:40 2012 */
#line 1 "parsers/MshParser.c++.re2c"
#include "MshParser.h++"

#include <iostream>	// for cerr
#include <cstdlib>	// for strtol, strtod

#include <boost/lexical_cast.hpp>


MshParser::MshParser()
{
	setParserTable();

	// set the operators
	surface_load_operator = nullptr;
}


enum MshParser::Error::Type  
MshParser::parse(std::istream &file, fem::Model &model)
{
	ss.push(NT_START);	// initializes the symbol stack with  the start symbol

	enum TerminalToken terminal_token = lexer(file);
	std::cout << "TT_OPEN_MESH_FORMAT" << std::endl;

	enum ParserRule parser_rule;	// debugging purposes only
	int nonterminal_token;

	// resets the error message
	this->error.code = Error::ERR_OK;
	this->error.message.clear();

	// set the temp variable's default values
	load_pattern.label = "Default MSH import load pattern";
	//TODO set default material

	while(!ss.empty())
	{
		if(terminal_token == ss.top())
		{
			ss.pop();
			terminal_token = lexer(file);
			switch(terminal_token)
			{
				case TT_ERROR:
					std::cout << "TT_ERROR" << std::endl;
					break;
				case TT_OPEN_MESH_FORMAT:
					std::cout << "TT_OPEN_MESH_FORMAT" << std::endl;
					break;
				case TT_CLOSE_MESH_FORMAT:
					std::cout << "TT_CLOSE_MESH_FORMAT" << std::endl;
					break;
				case TT_OPEN_NODES:
					std::cout << "TT_OPEN_NODES" << std::endl;
					break;
				case TT_CLOSE_NODES:
					std::cout << "TT_CLOSE_NODES" << std::endl;
					break;
				case TT_OPEN_ELEMENTS:
					std::cout << "TT_OPEN_ELEMENTS" << std::endl;
					break;
				case TT_CLOSE_ELEMENTS:
					std::cout << "TT_CLOSE_ELEMENTS" << std::endl;
					break;
				case TT_OPEN_PHYSICAL_NAMES:
					std::cout << "TT_OPEN_PHYSICAL_NAMES" << std::endl;
					break;
				case TT_CLOSE_PHYSICAL_NAMES:
					std::cout << "TT_CLOSE_PHYSICAL_NAMES" << std::endl;
					break;
				case TT_OPEN_NODE_DATA:
					std::cout << "TT_OPEN_NODE_DATA" << std::endl;
					break;
				case TT_CLOSE_NODE_DATA:
					std::cout << "TT_CLOSE_NODE_DATA" << std::endl;
					break;
				case TT_OPEN_ELEMENT_DATA:
					std::cout << "TT_OPEN_ELEMENT_DATA" << std::endl;
					break;
				case TT_CLOSE_ELEMENT_DATA:
					std::cout << "TT_CLOSE_ELEMENT_DATA" << std::endl;
					break;
				case TT_OPEN_ELEMENT_NODE_DATA:
					std::cout << "TT_OPEN_ELEMENT_NODE_DATA" << std::endl;
					break;
				case TT_CLOSE_ELEMENT_NODE_DATA:
					std::cout << "TT_CLOSE_ELEMENT_NODE_DATA" << std::endl;
					break;
				case TT_INDEX:
					std::cout << "TT_INDEX" << std::endl;
					break;
				case TT_NUMBER:
					std::cout << "TT_NUMBER" << std::endl;
					break;
				case TT_ELEMENT_LINE2:
					std::cout << "TT_ELEMENT_LINE2" << std::endl;
					break;
				case TT_ELEMENT_TRIANGLE3:
					std::cout << "TT_ELEMENT_TRIANGLE3" << std::endl;
					break;
				case TT_ELEMENT_QUADRANGLE4:
					std::cout << "TT_ELEMENT_QUADRANGLE4" << std::endl;
					break;
				case TT_ELEMENT_TETRAHEDRON4:
					std::cout << "TT_ELEMENT_TETRAHEDRON4" << std::endl;
					break;
				case TT_ELEMENT_HEXAHEDRON8:
					std::cout << "TT_ELEMENT_HEXAHEDRON8" << std::endl;
					break;
				case TT_ELEMENT_PRISM6:
					std::cout << "TT_ELEMENT_PRISM6" << std::endl;
					break;
				case TT_ELEMENT_PYRAMID5:
					std::cout << "TT_ELEMENT_PYRAMID5" << std::endl;
					break;
				case TT_ELEMENT_LINE3:
					std::cout << "TT_ELEMENT_LINE3" << std::endl;
					break;
				case TT_ELEMENT_TRIANGLE6:
					std::cout << "TT_ELEMENT_TRIANGLE6" << std::endl;
					break;
				case TT_ELEMENT_QUADRANGLE9:
					std::cout << "TT_ELEMENT_QUADRANGLE9" << std::endl;
					break;
				case TT_ELEMENT_TETRAHEDRON10:
					std::cout << "TT_ELEMENT_TETRAHEDRON10" << std::endl;
					break;
				case TT_ELEMENT_HEXAHEDRON27:
					std::cout << "TT_ELEMENT_HEXAHEDRON27" << std::endl;
					break;
				case TT_ELEMENT_PRISM18:
					std::cout << "TT_ELEMENT_PRISM18" << std::endl;
					break;
				case TT_ELEMENT_PYRAMID14:
					std::cout << "TT_ELEMENT_PYRAMID14" << std::endl;
					break;
				case TT_ELEMENT_POINT:
					std::cout << "TT_ELEMENT_POINT" << std::endl;
					break;
				case TT_ELEMENT_QUADRANGLE8:
					std::cout << "TT_ELEMENT_QUADRANGLE8" << std::endl; break;
				case TT_ELEMENT_HEXAHEDRON20:
					std::cout << "TT_ELEMENT_HEXAHEDRON20" << std::endl;
					break;
				case TT_ELEMENT_PRISM15:
					std::cout << "TT_ELEMENT_PRISM15" << std::endl;
					break;
				case TT_ELEMENT_PYRAMID13:
					std::cout << "TT_ELEMENT_PYRAMID13" << std::endl;
					break;
				case TT_ELEMENT_ITRIANGLE9:
					std::cout << "TT_ELEMENT_ITRIANGLE9" << std::endl;
					break;
				case TT_ELEMENT_TRIANGLE10:
					std::cout << "TT_ELEMENT_TRIANGLE10" << std::endl;
					break;
				case TT_ELEMENT_ITRIANGLE12:
					std::cout << "TT_ELEMENT_ITRIANGLE12" << std::endl;
					break;
				case TT_ELEMENT_TRIANGLE15:
					std::cout << "TT_ELEMENT_TRIANGLE15" << std::endl;
					break;
				case TT_ELEMENT_ITRIANGLE15:
					std::cout << "TT_ELEMENT_ITRIANGLE15" << std::endl;
					break;
				case TT_ELEMENT_TRIANGLE21:
					std::cout << "TT_ELEMENT_TRIANGLE21" << std::endl;
					break;
				case TT_ELEMENT_EDGE4:
					std::cout << "TT_ELEMENT_EDGE4" << std::endl;
					break;
				case TT_ELEMENT_EDGE5:
					std::cout << "TT_ELEMENT_EDGE5" << std::endl;
					break;
				case TT_ELEMENT_EDGE6:
					std::cout << "TT_ELEMENT_EDGE6" << std::endl;
					break;
				case TT_ELEMENT_TETRAHEDRON20:
					std::cout << "TT_ELEMENT_TETRAHEDRON20" << std::endl;
					break;
				case TT_ELEMENT_TETRAHEDRON35:
					std::cout << "TT_ELEMENT_TETRAHEDRON35" << std::endl;
					break;
				case TT_ELEMENT_TETRAHEDRON56:
					std::cout << "TT_ELEMENT_TETRAHEDRON56" << std::endl;
					break;
				case TT_0_TAGS:
					std::cout << "TT_0_TAGS" << std::endl;
					break;
				case TT_1_TAGS:
					std::cout << "TT_1_TAGS" << std::endl;
					break;
				case TT_2_TAGS:
					std::cout << "TT_2_TAGS" << std::endl;
					break;
				case TT_3_TAGS:
					std::cout << "TT_3_TAGS" << std::endl;
					break;
				case TT_EOL:
					std::cout << "TT_EOL" << std::endl;
					break;
				case TT_EOF:
					std::cout << "TT_EOF" << std::endl;
					break;
				case TT_VERSION_2_1:
					std::cout << "TT_VERSION_2_1" << std::endl;
					break;
				case TT_VERSION_2_2:
					std::cout << "TT_VERSION_2_2" << std::endl;
					break;
				case TT_MF_FILE_TYPE_ASCII:
					std::cout << "TT_MF_FILE_TYPE_ASCII" << std::endl;
					break;
				case TT_MF_DATA_SIZE:
					std::cout << "TT_MF_DATA_SIZE" << std::endl;
					break;
				case TT_UNKNOWN_TOKEN:
					std::cout << "TT_UNKNOWN_TOKEN" << std::endl;
					break;
				default:
					std::cout << "default" << std::endl;
			}
		}
		else
		{
			nonterminal_token = ss.top();
			ss.pop();
			parser_rule = table[(enum NonTerminalToken)nonterminal_token][terminal_token];
			switch(parser_rule) 
			{
				case PR_START:
					ss.push(TT_EOF);
					ss.push(NT_DOCUMENT);
					break;

				case PR_DOCUMENT:
					ss.push(NT_ELEMENTS_FOLLOW);
					ss.push(NT_ELEMENTS);
					ss.push(NT_NODES);
					ss.push(NT_HEADER);
					break;

				case PR_HEADER:
					/*
					ss.push(TT_CLOSE_MESH_FORMAT);
					ss.push(NT_MF_DATA_SIZE);
					ss.push(NT_MF_FILE_TYPE);
					*/
					ss.push(TT_EOL);
					ss.push(TT_CLOSE_MESH_FORMAT);
					ss.push(NT_MF_VERSION_NUMBER);
					ss.push(TT_EOL);
					ss.push(TT_OPEN_MESH_FORMAT);
					break;
					
				case PR_MF_VERSION_NUMBER_2_1:
					ss.push(TT_EOL);
					ss.push(NT_MF_DATA_SIZE);
					ss.push(NT_MF_FILE_TYPE);
					ss.push(TT_VERSION_2_1);
					break;
				
				case PR_MF_VERSION_NUMBER_2_2:
					ss.push(TT_EOL);
					ss.push(NT_MF_DATA_SIZE);
					ss.push(NT_MF_FILE_TYPE);
					ss.push(TT_VERSION_2_2);
					break;

				case PR_MF_VERSION_NUMBER_ERROR:
					this->error.code = Error::ERR_UNSUPPORTED_VERSION;
					this->error.message = "Unsupported version";
					return this->error.code;
					break;

				case PR_MF_FILE_TYPE_ASCII:
					ss.push(TT_MF_FILE_TYPE_ASCII);
					break;

				case PR_MF_DATA_SIZE:
					ss.push(TT_MF_DATA_SIZE);
					break;

				// start parsing the nodes field
				case PR_NODES:
					ss.push(TT_EOL);
					ss.push(TT_CLOSE_NODES);
					ss.push(NT_N_NODE_DEFINITION_FOLLOW);
					ss.push(NT_N_NODE_DEFINITION);
					ss.push(NT_N_NUMBER_OF_NODES);
					ss.push(TT_EOL);
					ss.push(TT_OPEN_NODES);
					break;

				case PR_N_NUMBER_OF_NODES:
					ss.push(TT_EOL);
					ss.push(TT_INDEX);
					break;

				case PR_N_NUMBER_OF_NODES_SET:
					//TODO set limit to how many nodes have been parsed
					index_list.pop_back();	// clear up the stack
					break;

				case PR_N_NODE_DEFINITION:
					ss.push(TT_EOL);
					ss.push(NT_N_NODE_DEFINITION_SET);
					ss.push(NT_COORDINATE);
					ss.push(TT_INDEX);
					break;

				case PR_N_NODE_DEFINITION_SET:
					// set the node coordinates
					node.x(float_list.front());
					float_list.pop_front();
					node.y(float_list.front());
					float_list.pop_front();
					node.z(float_list.front());
					float_list.pop_front();

					// set the node
					model.setNode(index_list.back(), node);
					index_list.pop_back();
					break;

				case PR_N_NODE_DEFINITION_FOLLOW_1:
					ss.push(NT_N_NODE_DEFINITION_FOLLOW);
					ss.push(NT_N_NODE_DEFINITION);
					break;

				case PR_N_NODE_DEFINITION_FOLLOW_2:
					break;

				// start parsing the element field
				case PR_ELEMENTS:
					ss.push(TT_EOL);
					ss.push(NT_ELEMENTS_SET);
					ss.push(TT_CLOSE_ELEMENTS);
					ss.push(NT_E_ELEMENT_DEFINITION_FOLLOW);
					ss.push(NT_E_ELEMENT_DEFINITION);
					ss.push(NT_E_NUMBER_OF_ELEMENTS);
					ss.push(TT_EOL);
					ss.push(TT_OPEN_ELEMENTS);
					break;

				case PR_E_NUMBER_OF_ELEMENTS:
					//TODO set limit to how many elements have been parsed
					ss.push(TT_EOL);
					ss.push(NT_E_NUMBER_OF_ELEMENTS_SET);
					ss.push(TT_INDEX);
					break;

				case PR_E_NUMBER_OF_ELEMENTS_SET:
					model.element_list.reserve(index_list.back());
					index_list.pop_back();	
					break;

				case PR_E_ELEMENT_DEFINITION:
					ss.push(TT_EOL);
					ss.push(NT_E_ELEMENT_TYPE);
					ss.push(TT_INDEX);
					break;

				case PR_E_ELEMENT_TRIANGLE3:
					surface_load.type = fem::Element::FE_TRIANGLE3;
					ss.push(NT_E_ELEMENT_TYPE_SET_FORCE);
					for(int i = 0; i < 3; i++) ss.push(TT_INDEX);
					ss.push(NT_E_TAGS);
					ss.push(TT_ELEMENT_TRIANGLE3);
					break;

				case PR_E_ELEMENT_TRIANGLE6:
					surface_load.type = fem::Element::FE_TRIANGLE6;
					ss.push(NT_E_ELEMENT_TYPE_SET_FORCE);
					for(int i = 0; i < 6; i++) ss.push(TT_INDEX);
					ss.push(NT_E_TAGS);
					ss.push(TT_ELEMENT_TRIANGLE6);
					break;

				case PR_E_ELEMENT_QUADRANGLE4:
					surface_load.type = fem::Element::FE_QUADRANGLE4;
					ss.push(NT_E_ELEMENT_TYPE_SET_FORCE);
					for(int i = 0; i < 4; i++) ss.push(TT_INDEX);
					ss.push(NT_E_TAGS);
					ss.push(TT_ELEMENT_QUADRANGLE4);
					break;

				case PR_E_ELEMENT_QUADRANGLE8:
					surface_load.type = fem::Element::FE_QUADRANGLE8;
					ss.push(NT_E_ELEMENT_TYPE_SET_FORCE);
					for(int i = 0; i < 8; i++) ss.push(TT_INDEX);
					ss.push(NT_E_TAGS);
					ss.push(TT_ELEMENT_QUADRANGLE8);
					break;

				case PR_E_ELEMENT_QUADRANGLE9:
					ss.push(NT_E_ELEMENT_TYPE_SET_FORCE);
					surface_load.type = fem::Element::FE_QUADRANGLE9;
					for(int i = 0; i < 9; i++) ss.push(TT_INDEX);
					ss.push(NT_E_TAGS);
					ss.push(TT_ELEMENT_QUADRANGLE9);
					break;

				case PR_E_ELEMENT_HEXAHEDRON8:
					element.type = fem::Element::FE_HEXAHEDRON8;
					ss.push(NT_E_ELEMENT_TYPE_SET_ELEMENT);
					for(int i = 0; i < 8; i++) ss.push(TT_INDEX);
					ss.push(NT_E_TAGS);
					ss.push(TT_ELEMENT_HEXAHEDRON8);
					break;

				case PR_E_ELEMENT_HEXAHEDRON20:
					element.type = fem::Element::FE_HEXAHEDRON20;
					ss.push(NT_E_ELEMENT_TYPE_SET_ELEMENT);
					for(int i = 0; i < 20; i++) ss.push(TT_INDEX);
					ss.push(NT_E_TAGS);
					ss.push(TT_ELEMENT_HEXAHEDRON20);
					break;

				case PR_E_ELEMENT_HEXAHEDRON27:
					element.type = fem::Element::FE_HEXAHEDRON27;
					ss.push(NT_E_ELEMENT_TYPE_SET_ELEMENT);
					for(int i = 7; i < 20; i++) ss.push(TT_INDEX);
					ss.push(NT_E_TAGS);
					ss.push(TT_ELEMENT_HEXAHEDRON27);
					break;

				case PR_E_ELEMENT_TETRAHEDRON4:
					element.type = fem::Element::FE_TETRAHEDRON4;
					ss.push(NT_E_ELEMENT_TYPE_SET_ELEMENT);
					for(int i = 0; i < 4; i++) ss.push(TT_INDEX);
					ss.push(NT_E_TAGS);
					ss.push(TT_ELEMENT_TETRAHEDRON4);
					break;

				case PR_E_ELEMENT_TETRAHEDRON10:
					element.type = fem::Element::FE_TETRAHEDRON10;
					ss.push(NT_E_ELEMENT_TYPE_SET_ELEMENT);
					for(int i = 0; i < 10; i++) ss.push(TT_INDEX);
					ss.push(NT_E_TAGS);
					ss.push(TT_ELEMENT_TETRAHEDRON10);
					break;

				case PR_E_ELEMENT_PRISM6:
					element.type = fem::Element::FE_PRISM6;
					ss.push(NT_E_ELEMENT_TYPE_SET_ELEMENT);
					for(int i = 0; i < 6; i++) ss.push(TT_INDEX);
					ss.push(NT_E_TAGS);
					ss.push(TT_ELEMENT_PRISM6);
					break;

				case PR_E_ELEMENT_PRISM15:
					element.type = fem::Element::FE_PRISM15;
					ss.push(NT_E_ELEMENT_TYPE_SET_ELEMENT);
					for(int i = 0; i < 15; i++) ss.push(TT_INDEX);
					ss.push(NT_E_TAGS);
					ss.push(TT_ELEMENT_PRISM15);
					break;

				case PR_E_ELEMENT_PRISM18:
					element.type = fem::Element::FE_PRISM18;
					ss.push(NT_E_ELEMENT_TYPE_SET_ELEMENT);
					for(int i = 0; i < 18; i++) ss.push(TT_INDEX);
					ss.push(NT_E_TAGS);
					ss.push(TT_ELEMENT_PRISM18);
					break;

				case PR_E_ELEMENT_TYPE_SET_ELEMENT:
					index_list.pop_front();	// get rid of element index
					index_list.pop_front();	// get rid of element type: nasty hack
					element.nodes.assign(index_list.begin(), index_list.end());
					index_list.clear();
					model.pushElement(element);
					break;

				case PR_E_ELEMENT_TYPE_SET_FORCE:
					index_list.pop_front();	// get rid of element index
					index_list.pop_front();	// get rid of element type: nasty hack
					if(surface_load_operator)
					{
						surface_load.nodes.assign(index_list.begin(), index_list.end());
						surface_load.surface_forces.resize(surface_load.nodes.size());

						//TODO finish this
						(*surface_load_operator)(surface_load, model);

						index_list.clear();
						load_pattern.addSurfaceLoad(surface_load);
					}
					break;
					
				case PR_E_ELEMENT_DEFINITION_FOLLOW_1:
					ss.push(NT_E_ELEMENT_DEFINITION_FOLLOW);
					ss.push(NT_E_ELEMENT_DEFINITION);
					break;
				
				case PR_E_ELEMENT_DEFINITION_FOLLOW_2:
					break;

				case PR_E_TAGS_0:
					ss.push(TT_0_TAGS);
					break;

				case PR_E_TAGS_1:
					//TODO test this
					ss.push(NT_E_TAGS_1_SET);
					ss.push(TT_INDEX);
					ss.push(TT_1_TAGS);
					break;

				case PR_E_TAGS_2:
					//TODO test this
					ss.push(NT_E_TAGS_2_SET);
					ss.push(TT_INDEX);
					ss.push(TT_INDEX);
					ss.push(TT_2_TAGS);
					break;

				case PR_E_TAGS_3:
					//TODO test this
					ss.push(NT_E_TAGS_3_SET);
					ss.push(TT_INDEX);
					ss.push(TT_INDEX);
					ss.push(TT_INDEX);
					ss.push(TT_3_TAGS);
					break;

				case PR_E_TAGS_1_SET:
					index_list.pop_front();
					break;

				case PR_E_TAGS_2_SET:
					index_list.pop_front();
					index_list.pop_front();
					break;

				case PR_E_TAGS_3_SET:
					index_list.pop_front();
					index_list.pop_front();
					index_list.pop_front();
					break;

				case PR_ELEMENTS_SET:
					if(!load_pattern.empty())
						model.pushLoadPattern(load_pattern);
					break;

				case PR_ELEMENT_FOLLOW_1:
				case PR_ELEMENT_FOLLOW_2:
				case PR_ELEMENT_FOLLOW_3:
					this->error.code = Error::ERR_UNKNOWN;
					this->error.message = "Section is not supported" + boost::lexical_cast<std::string>(line_number);
					return this->error.code;
					break;

				case PR_ELEMENT_FOLLOW_4:
					break;

				case PR_COORDINATE:		// requires 3 floats, sets a point with them
					//TODO set a vector
					ss.push(TT_NUMBER);
					ss.push(TT_NUMBER);
					ss.push(TT_NUMBER);
					break;

				default:
					this->error.code = Error::ERR_UNKNOWN;
					this->error.message = "Unknown error while parsing line " + boost::lexical_cast<std::string>(line_number);
					return this->error.code;
					break;
			}
		}
	}

	// all is good
	this->error.code = Error::ERR_OK;
	this->error.message.clear();
	return this->error.code;
}


enum MshParser::TerminalToken MshParser::lexer(std::istream &file)
{
	tok = pos;
std:
	switch(lex_state)
	{
		case 0:
		{
	#define YYFILL fill(file);
	
#line 596 "parsers/MshParser.c++"
{
	char yych;

	if ((limit - pos) < 16) YYFILL(16);
	yych = *pos;
	switch (yych) {
	case 0x00:	goto yy6;
	case '\n':	goto yy4;
	case ' ':	goto yy8;
	case '$':	goto yy2;
	default:	goto yy10;
	}
yy2:
	yych = *(marker = ++pos);
	switch (yych) {
	case 'E':	goto yy13;
	case 'M':	goto yy17;
	case 'N':	goto yy15;
	case 'P':	goto yy16;
	default:	goto yy3;
	}
yy3:
#line 615 "parsers/MshParser.c++.re2c"
	{ return TT_UNKNOWN_TOKEN; }
#line 621 "parsers/MshParser.c++"
yy4:
	++pos;
#line 612 "parsers/MshParser.c++.re2c"
	{ line_number++; return TT_EOL; }
#line 626 "parsers/MshParser.c++"
yy6:
	++pos;
#line 613 "parsers/MshParser.c++.re2c"
	{ return TT_EOF;	}
#line 631 "parsers/MshParser.c++"
yy8:
	++pos;
	yych = *pos;
	goto yy12;
yy9:
#line 614 "parsers/MshParser.c++.re2c"
	{ goto std;}
#line 639 "parsers/MshParser.c++"
yy10:
	yych = *++pos;
	goto yy3;
yy11:
	++pos;
	if (limit <= pos) YYFILL(1);
	yych = *pos;
yy12:
	switch (yych) {
	case ' ':	goto yy11;
	default:	goto yy9;
	}
yy13:
	yych = *++pos;
	switch (yych) {
	case 'l':	goto yy51;
	default:	goto yy14;
	}
yy14:
	pos = marker;
	goto yy3;
yy15:
	yych = *++pos;
	switch (yych) {
	case 'o':	goto yy41;
	default:	goto yy14;
	}
yy16:
	yych = *++pos;
	switch (yych) {
	case 'h':	goto yy28;
	default:	goto yy14;
	}
yy17:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy18;
	default:	goto yy14;
	}
yy18:
	yych = *++pos;
	switch (yych) {
	case 's':	goto yy19;
	default:	goto yy14;
	}
yy19:
	yych = *++pos;
	switch (yych) {
	case 'h':	goto yy20;
	default:	goto yy14;
	}
yy20:
	yych = *++pos;
	switch (yych) {
	case 'F':	goto yy21;
	default:	goto yy14;
	}
yy21:
	yych = *++pos;
	switch (yych) {
	case 'o':	goto yy22;
	default:	goto yy14;
	}
yy22:
	yych = *++pos;
	switch (yych) {
	case 'r':	goto yy23;
	default:	goto yy14;
	}
yy23:
	yych = *++pos;
	switch (yych) {
	case 'm':	goto yy24;
	default:	goto yy14;
	}
yy24:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy25;
	default:	goto yy14;
	}
yy25:
	yych = *++pos;
	switch (yych) {
	case 't':	goto yy26;
	default:	goto yy14;
	}
yy26:
	++pos;
#line 605 "parsers/MshParser.c++.re2c"
	{ lex_state = 1; return TT_OPEN_MESH_FORMAT;	}
#line 731 "parsers/MshParser.c++"
yy28:
	yych = *++pos;
	switch (yych) {
	case 'y':	goto yy29;
	default:	goto yy14;
	}
yy29:
	yych = *++pos;
	switch (yych) {
	case 's':	goto yy30;
	default:	goto yy14;
	}
yy30:
	yych = *++pos;
	switch (yych) {
	case 'i':	goto yy31;
	default:	goto yy14;
	}
yy31:
	yych = *++pos;
	switch (yych) {
	case 'c':	goto yy32;
	default:	goto yy14;
	}
yy32:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy33;
	default:	goto yy14;
	}
yy33:
	yych = *++pos;
	switch (yych) {
	case 'l':	goto yy34;
	default:	goto yy14;
	}
yy34:
	yych = *++pos;
	switch (yych) {
	case 'N':	goto yy35;
	default:	goto yy14;
	}
yy35:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy36;
	default:	goto yy14;
	}
yy36:
	yych = *++pos;
	switch (yych) {
	case 'm':	goto yy37;
	default:	goto yy14;
	}
yy37:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy38;
	default:	goto yy14;
	}
yy38:
	yych = *++pos;
	switch (yych) {
	case 's':	goto yy39;
	default:	goto yy14;
	}
yy39:
	++pos;
#line 608 "parsers/MshParser.c++.re2c"
	{ return TT_OPEN_PHYSICAL_NAMES;	}
#line 802 "parsers/MshParser.c++"
yy41:
	yych = *++pos;
	switch (yych) {
	case 'd':	goto yy42;
	default:	goto yy14;
	}
yy42:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy43;
	default:	goto yy14;
	}
yy43:
	yych = *++pos;
	switch (yych) {
	case 'D':	goto yy44;
	case 's':	goto yy45;
	default:	goto yy14;
	}
yy44:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy47;
	default:	goto yy14;
	}
yy45:
	++pos;
#line 606 "parsers/MshParser.c++.re2c"
	{ lex_state = 2; return TT_OPEN_NODES;	}
#line 832 "parsers/MshParser.c++"
yy47:
	yych = *++pos;
	switch (yych) {
	case 't':	goto yy48;
	default:	goto yy14;
	}
yy48:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy49;
	default:	goto yy14;
	}
yy49:
	++pos;
#line 609 "parsers/MshParser.c++.re2c"
	{ return TT_OPEN_NODE_DATA;	}
#line 849 "parsers/MshParser.c++"
yy51:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy52;
	default:	goto yy14;
	}
yy52:
	yych = *++pos;
	switch (yych) {
	case 'm':	goto yy53;
	default:	goto yy14;
	}
yy53:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy54;
	default:	goto yy14;
	}
yy54:
	yych = *++pos;
	switch (yych) {
	case 'n':	goto yy55;
	default:	goto yy14;
	}
yy55:
	yych = *++pos;
	switch (yych) {
	case 't':	goto yy56;
	default:	goto yy14;
	}
yy56:
	yych = *++pos;
	switch (yych) {
	case 'D':	goto yy59;
	case 'N':	goto yy60;
	case 's':	goto yy57;
	default:	goto yy14;
	}
yy57:
	++pos;
#line 607 "parsers/MshParser.c++.re2c"
	{ lex_state = 4; return TT_OPEN_ELEMENTS;	}
#line 892 "parsers/MshParser.c++"
yy59:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy69;
	default:	goto yy14;
	}
yy60:
	yych = *++pos;
	switch (yych) {
	case 'o':	goto yy61;
	default:	goto yy14;
	}
yy61:
	yych = *++pos;
	switch (yych) {
	case 'd':	goto yy62;
	default:	goto yy14;
	}
yy62:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy63;
	default:	goto yy14;
	}
yy63:
	yych = *++pos;
	switch (yych) {
	case 'D':	goto yy64;
	default:	goto yy14;
	}
yy64:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy65;
	default:	goto yy14;
	}
yy65:
	yych = *++pos;
	switch (yych) {
	case 't':	goto yy66;
	default:	goto yy14;
	}
yy66:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy67;
	default:	goto yy14;
	}
yy67:
	++pos;
#line 611 "parsers/MshParser.c++.re2c"
	{ return TT_OPEN_ELEMENT_NODE_DATA;	}
#line 945 "parsers/MshParser.c++"
yy69:
	yych = *++pos;
	switch (yych) {
	case 't':	goto yy70;
	default:	goto yy14;
	}
yy70:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy71;
	default:	goto yy14;
	}
yy71:
	++pos;
#line 610 "parsers/MshParser.c++.re2c"
	{ return TT_OPEN_ELEMENT_DATA;	}
#line 962 "parsers/MshParser.c++"
}
#line 616 "parsers/MshParser.c++.re2c"

		}
		break;

		case 1:	// get parser version as a lexer token
		{
	
#line 972 "parsers/MshParser.c++"
{
	char yych;
	unsigned int yyaccept = 0;
	if ((limit - pos) < 14) YYFILL(14);
	yych = *pos;
	switch (yych) {
	case 0x00:	goto yy84;
	case '\n':	goto yy82;
	case ' ':	goto yy86;
	case '$':	goto yy80;
	case '0':	goto yy77;
	case '1':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy79;
	case '2':	goto yy75;
	default:	goto yy88;
	}
yy75:
	yyaccept = 0;
	yych = *(marker = ++pos);
	switch (yych) {
	case '.':	goto yy106;
	default:	goto yy76;
	}
yy76:
#line 626 "parsers/MshParser.c++.re2c"
	{ return TT_MF_DATA_SIZE;	}
#line 1005 "parsers/MshParser.c++"
yy77:
	++pos;
#line 625 "parsers/MshParser.c++.re2c"
	{ return TT_MF_FILE_TYPE_ASCII;	}
#line 1010 "parsers/MshParser.c++"
yy79:
	yych = *++pos;
	goto yy76;
yy80:
	yyaccept = 1;
	yych = *(marker = ++pos);
	switch (yych) {
	case 'E':	goto yy91;
	default:	goto yy81;
	}
yy81:
#line 631 "parsers/MshParser.c++.re2c"
	{ return TT_UNKNOWN_TOKEN; }
#line 1024 "parsers/MshParser.c++"
yy82:
	++pos;
#line 628 "parsers/MshParser.c++.re2c"
	{ line_number++; return TT_EOL; }
#line 1029 "parsers/MshParser.c++"
yy84:
	++pos;
#line 629 "parsers/MshParser.c++.re2c"
	{ return TT_EOF;	}
#line 1034 "parsers/MshParser.c++"
yy86:
	++pos;
	yych = *pos;
	goto yy90;
yy87:
#line 630 "parsers/MshParser.c++.re2c"
	{ goto std;	}
#line 1042 "parsers/MshParser.c++"
yy88:
	yych = *++pos;
	goto yy81;
yy89:
	++pos;
	if (limit <= pos) YYFILL(1);
	yych = *pos;
yy90:
	switch (yych) {
	case ' ':	goto yy89;
	default:	goto yy87;
	}
yy91:
	yych = *++pos;
	switch (yych) {
	case 'n':	goto yy93;
	default:	goto yy92;
	}
yy92:
	pos = marker;
	switch (yyaccept) {
	case 0: 	goto yy76;
	case 1: 	goto yy81;
	}
yy93:
	yych = *++pos;
	switch (yych) {
	case 'd':	goto yy94;
	default:	goto yy92;
	}
yy94:
	yych = *++pos;
	switch (yych) {
	case 'M':	goto yy95;
	default:	goto yy92;
	}
yy95:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy96;
	default:	goto yy92;
	}
yy96:
	yych = *++pos;
	switch (yych) {
	case 's':	goto yy97;
	default:	goto yy92;
	}
yy97:
	yych = *++pos;
	switch (yych) {
	case 'h':	goto yy98;
	default:	goto yy92;
	}
yy98:
	yych = *++pos;
	switch (yych) {
	case 'F':	goto yy99;
	default:	goto yy92;
	}
yy99:
	yych = *++pos;
	switch (yych) {
	case 'o':	goto yy100;
	default:	goto yy92;
	}
yy100:
	yych = *++pos;
	switch (yych) {
	case 'r':	goto yy101;
	default:	goto yy92;
	}
yy101:
	yych = *++pos;
	switch (yych) {
	case 'm':	goto yy102;
	default:	goto yy92;
	}
yy102:
	yych = *++pos;
	switch (yych) {
	case 'a':	goto yy103;
	default:	goto yy92;
	}
yy103:
	yych = *++pos;
	switch (yych) {
	case 't':	goto yy104;
	default:	goto yy92;
	}
yy104:
	++pos;
#line 627 "parsers/MshParser.c++.re2c"
	{ lex_state = 0;	return TT_CLOSE_MESH_FORMAT; }
#line 1137 "parsers/MshParser.c++"
yy106:
	yych = *++pos;
	switch (yych) {
	case '1':	goto yy107;
	case '2':	goto yy109;
	default:	goto yy92;
	}
yy107:
	++pos;
#line 623 "parsers/MshParser.c++.re2c"
	{ return TT_VERSION_2_1;	}
#line 1149 "parsers/MshParser.c++"
yy109:
	++pos;
#line 624 "parsers/MshParser.c++.re2c"
	{ return TT_VERSION_2_1;	}
#line 1154 "parsers/MshParser.c++"
}
#line 632 "parsers/MshParser.c++.re2c"

		}
		break;

		case 2:	// parse nodes section: index
		{
	
#line 1164 "parsers/MshParser.c++"
{
	char yych;
	if ((limit - pos) < 9) YYFILL(9);
	yych = *pos;
	switch (yych) {
	case 0x00:	goto yy120;
	case '\n':	goto yy118;
	case ' ':	goto yy122;
	case '$':	goto yy116;
	case '0':	goto yy113;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy115;
	default:	goto yy124;
	}
yy113:
	++pos;
yy114:
#line 639 "parsers/MshParser.c++.re2c"
	{ 
			lex_state = 3; 
			setIndex(); 
			return TT_INDEX; 
		}
#line 1195 "parsers/MshParser.c++"
yy115:
	yych = *++pos;
	goto yy138;
yy116:
	yych = *(marker = ++pos);
	switch (yych) {
	case 'E':	goto yy127;
	default:	goto yy117;
	}
yy117:
#line 648 "parsers/MshParser.c++.re2c"
	{ return TT_UNKNOWN_TOKEN; }
#line 1208 "parsers/MshParser.c++"
yy118:
	++pos;
#line 645 "parsers/MshParser.c++.re2c"
	{ line_number++; return TT_EOL; }
#line 1213 "parsers/MshParser.c++"
yy120:
	++pos;
#line 646 "parsers/MshParser.c++.re2c"
	{ return TT_EOF;	}
#line 1218 "parsers/MshParser.c++"
yy122:
	++pos;
	yych = *pos;
	goto yy126;
yy123:
#line 647 "parsers/MshParser.c++.re2c"
	{ goto std;	}
#line 1226 "parsers/MshParser.c++"
yy124:
	yych = *++pos;
	goto yy117;
yy125:
	++pos;
	if (limit <= pos) YYFILL(1);
	yych = *pos;
yy126:
	switch (yych) {
	case ' ':	goto yy125;
	default:	goto yy123;
	}
yy127:
	yych = *++pos;
	switch (yych) {
	case 'n':	goto yy129;
	default:	goto yy128;
	}
yy128:
	pos = marker;
	goto yy117;
yy129:
	yych = *++pos;
	switch (yych) {
	case 'd':	goto yy130;
	default:	goto yy128;
	}
yy130:
	yych = *++pos;
	switch (yych) {
	case 'N':	goto yy131;
	default:	goto yy128;
	}
yy131:
	yych = *++pos;
	switch (yych) {
	case 'o':	goto yy132;
	default:	goto yy128;
	}
yy132:
	yych = *++pos;
	switch (yych) {
	case 'd':	goto yy133;
	default:	goto yy128;
	}
yy133:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy134;
	default:	goto yy128;
	}
yy134:
	yych = *++pos;
	switch (yych) {
	case 's':	goto yy135;
	default:	goto yy128;
	}
yy135:
	++pos;
#line 644 "parsers/MshParser.c++.re2c"
	{ lex_state = 0;	return TT_CLOSE_NODES; }
#line 1288 "parsers/MshParser.c++"
yy137:
	++pos;
	if (limit <= pos) YYFILL(1);
	yych = *pos;
yy138:
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy137;
	default:	goto yy114;
	}
}
#line 649 "parsers/MshParser.c++.re2c"

		}
		break;

		case 3:	// parse nodes section: coordinates
		{
	
#line 1316 "parsers/MshParser.c++"
{
	char yych;
	if ((limit - pos) < 4) YYFILL(4);
	yych = *pos;
	switch (yych) {
	case 0x00:	goto yy148;
	case '\n':	goto yy146;
	case ' ':	goto yy150;
	case '-':	goto yy141;
	case '0':	goto yy143;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy145;
	default:	goto yy152;
	}
yy141:
	++pos;
	switch ((yych = *pos)) {
	case '0':	goto yy165;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy155;
	default:	goto yy142;
	}
yy142:
#line 660 "parsers/MshParser.c++.re2c"
	{ return TT_UNKNOWN_TOKEN; }
#line 1356 "parsers/MshParser.c++"
yy143:
	yych = *(marker = ++pos);
	switch (yych) {
	case '.':	goto yy157;
	default:	goto yy144;
	}
yy144:
#line 656 "parsers/MshParser.c++.re2c"
	{ setNumber(); return TT_NUMBER; }
#line 1366 "parsers/MshParser.c++"
yy145:
	yych = *(marker = ++pos);
	goto yy156;
yy146:
	++pos;
#line 657 "parsers/MshParser.c++.re2c"
	{ lex_state = 2; line_number++; return TT_EOL; }
#line 1374 "parsers/MshParser.c++"
yy148:
	++pos;
#line 658 "parsers/MshParser.c++.re2c"
	{ return TT_EOF;	}
#line 1379 "parsers/MshParser.c++"
yy150:
	++pos;
	yych = *pos;
	goto yy154;
yy151:
#line 659 "parsers/MshParser.c++.re2c"
	{ goto std;	}
#line 1387 "parsers/MshParser.c++"
yy152:
	yych = *++pos;
	goto yy142;
yy153:
	++pos;
	if (limit <= pos) YYFILL(1);
	yych = *pos;
yy154:
	switch (yych) {
	case ' ':	goto yy153;
	default:	goto yy151;
	}
yy155:
	marker = ++pos;
	if ((limit - pos) < 2) YYFILL(2);
	yych = *pos;
yy156:
	switch (yych) {
	case '.':	goto yy157;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy155;
	default:	goto yy144;
	}
yy157:
	yych = *++pos;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy159;
	default:	goto yy158;
	}
yy158:
	pos = marker;
	goto yy144;
yy159:
	marker = ++pos;
	if ((limit - pos) < 3) YYFILL(3);
	yych = *pos;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy159;
	case 'E':
	case 'e':	goto yy161;
	default:	goto yy144;
	}
yy161:
	yych = *++pos;
	switch (yych) {
	case '+':
	case '-':	goto yy162;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy163;
	default:	goto yy158;
	}
yy162:
	yych = *++pos;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy163;
	default:	goto yy158;
	}
yy163:
	++pos;
	if (limit <= pos) YYFILL(1);
	yych = *pos;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy163;
	default:	goto yy144;
	}
yy165:
	yych = *(marker = ++pos);
	switch (yych) {
	case '.':	goto yy157;
	default:	goto yy144;
	}
}
#line 661 "parsers/MshParser.c++.re2c"

		}
		break;

		case 4:	// parse elements section
		{
	
#line 1520 "parsers/MshParser.c++"
{
	char yych;
	if ((limit - pos) < 12) YYFILL(12);
	yych = *pos;
	switch (yych) {
	case 0x00:	goto yy175;
	case '\n':	goto yy173;
	case ' ':	goto yy177;
	case '$':	goto yy171;
	case '0':	goto yy168;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy170;
	default:	goto yy179;
	}
yy168:
	++pos;
yy169:
#line 668 "parsers/MshParser.c++.re2c"
	{ lex_state = 5; setIndex(); return TT_INDEX; }
#line 1547 "parsers/MshParser.c++"
yy170:
	yych = *++pos;
	goto yy196;
yy171:
	yych = *(marker = ++pos);
	switch (yych) {
	case 'E':	goto yy182;
	default:	goto yy172;
	}
yy172:
#line 673 "parsers/MshParser.c++.re2c"
	{ return TT_UNKNOWN_TOKEN; }
#line 1560 "parsers/MshParser.c++"
yy173:
	++pos;
#line 670 "parsers/MshParser.c++.re2c"
	{ line_number++; return TT_EOL; }
#line 1565 "parsers/MshParser.c++"
yy175:
	++pos;
#line 671 "parsers/MshParser.c++.re2c"
	{ return TT_EOF;	}
#line 1570 "parsers/MshParser.c++"
yy177:
	++pos;
	yych = *pos;
	goto yy181;
yy178:
#line 672 "parsers/MshParser.c++.re2c"
	{ goto std;	}
#line 1578 "parsers/MshParser.c++"
yy179:
	yych = *++pos;
	goto yy172;
yy180:
	++pos;
	if (limit <= pos) YYFILL(1);
	yych = *pos;
yy181:
	switch (yych) {
	case ' ':	goto yy180;
	default:	goto yy178;
	}
yy182:
	yych = *++pos;
	switch (yych) {
	case 'n':	goto yy184;
	default:	goto yy183;
	}
yy183:
	pos = marker;
	goto yy172;
yy184:
	yych = *++pos;
	switch (yych) {
	case 'd':	goto yy185;
	default:	goto yy183;
	}
yy185:
	yych = *++pos;
	switch (yych) {
	case 'E':	goto yy186;
	default:	goto yy183;
	}
yy186:
	yych = *++pos;
	switch (yych) {
	case 'l':	goto yy187;
	default:	goto yy183;
	}
yy187:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy188;
	default:	goto yy183;
	}
yy188:
	yych = *++pos;
	switch (yych) {
	case 'm':	goto yy189;
	default:	goto yy183;
	}
yy189:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy190;
	default:	goto yy183;
	}
yy190:
	yych = *++pos;
	switch (yych) {
	case 'n':	goto yy191;
	default:	goto yy183;
	}
yy191:
	yych = *++pos;
	switch (yych) {
	case 't':	goto yy192;
	default:	goto yy183;
	}
yy192:
	yych = *++pos;
	switch (yych) {
	case 's':	goto yy193;
	default:	goto yy183;
	}
yy193:
	++pos;
#line 669 "parsers/MshParser.c++.re2c"
	{ lex_state = 0;	return TT_CLOSE_ELEMENTS; }
#line 1658 "parsers/MshParser.c++"
yy195:
	++pos;
	if (limit <= pos) YYFILL(1);
	yych = *pos;
yy196:
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy195;
	default:	goto yy169;
	}
}
#line 674 "parsers/MshParser.c++.re2c"

		}
		break;

		case 5:	// parse element type
		{
	
#line 1686 "parsers/MshParser.c++"
{
	char yych;
	if ((limit - pos) < 2) YYFILL(2);
	yych = *pos;
	switch (yych) {
	case 0x00:	goto yy203;
	case '\n':	goto yy201;
	case ' ':	goto yy205;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy199;
	default:	goto yy207;
	}
yy199:
	++pos;
	yych = *pos;
	goto yy212;
yy200:
#line 681 "parsers/MshParser.c++.re2c"
	{
			setIndex();
			lex_state = 6;	// custom lexer to parse the tags
			switch(index_list.back())
			{
				case 2:return TT_ELEMENT_TRIANGLE3;
				case 3:return TT_ELEMENT_QUADRANGLE4;
				case 4:return TT_ELEMENT_TETRAHEDRON4;
				case 5:return TT_ELEMENT_HEXAHEDRON8;
				case 6:return TT_ELEMENT_PRISM6;
				case 7:return TT_ELEMENT_PYRAMID5;
				case 8:return TT_ELEMENT_LINE3;
				case 9:return TT_ELEMENT_TRIANGLE6;
				case 10:return TT_ELEMENT_QUADRANGLE9;
				case 11:return TT_ELEMENT_TETRAHEDRON10;
				case 12:return TT_ELEMENT_HEXAHEDRON27;
				case 13:return TT_ELEMENT_PRISM18;
				case 14:return TT_ELEMENT_PYRAMID14;
				case 15:return TT_ELEMENT_POINT;
				case 16:return TT_ELEMENT_QUADRANGLE8;
				case 17:return TT_ELEMENT_HEXAHEDRON20;
				case 18:return TT_ELEMENT_PRISM15;
				case 19:return TT_ELEMENT_PYRAMID13;
				case 20:return TT_ELEMENT_ITRIANGLE9;
				case 21:return TT_ELEMENT_TRIANGLE10;
				case 22:return TT_ELEMENT_ITRIANGLE12;
				case 23:return TT_ELEMENT_TRIANGLE15;
				case 24:return TT_ELEMENT_ITRIANGLE15;
				case 25:return TT_ELEMENT_TRIANGLE21;
				case 26:return TT_ELEMENT_EDGE4;
				case 27:return TT_ELEMENT_EDGE5;
				case 28:return TT_ELEMENT_EDGE6;
				case 29:return TT_ELEMENT_TETRAHEDRON20;
				case 30:return TT_ELEMENT_TETRAHEDRON35;
				case 31:return TT_ELEMENT_TETRAHEDRON56;
				default:
					return TT_UNKNOWN_TOKEN;
			}
		}
#line 1752 "parsers/MshParser.c++"
yy201:
	++pos;
#line 720 "parsers/MshParser.c++.re2c"
	{ lex_state = 4; line_number++; return TT_EOL; }
#line 1757 "parsers/MshParser.c++"
yy203:
	++pos;
#line 721 "parsers/MshParser.c++.re2c"
	{ return TT_EOF;	}
#line 1762 "parsers/MshParser.c++"
yy205:
	++pos;
	yych = *pos;
	goto yy210;
yy206:
#line 722 "parsers/MshParser.c++.re2c"
	{ goto std;	}
#line 1770 "parsers/MshParser.c++"
yy207:
	++pos;
#line 723 "parsers/MshParser.c++.re2c"
	{ return TT_UNKNOWN_TOKEN; }
#line 1775 "parsers/MshParser.c++"
yy209:
	++pos;
	if (limit <= pos) YYFILL(1);
	yych = *pos;
yy210:
	switch (yych) {
	case ' ':	goto yy209;
	default:	goto yy206;
	}
yy211:
	++pos;
	if (limit <= pos) YYFILL(1);
	yych = *pos;
yy212:
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy211;
	default:	goto yy200;
	}
}
#line 724 "parsers/MshParser.c++.re2c"

		}
		break;

	case 6:	// get number of tokens
		{
	
#line 1812 "parsers/MshParser.c++"
{
	char yych;
	if ((limit - pos) < 2) YYFILL(2);
	yych = *pos;
	switch (yych) {
	case 0x00:	goto yy216;
	case '\n':	goto yy215;
	case ' ':	goto yy218;
	case '0':	goto yy220;
	case '1':	goto yy222;
	case '2':	goto yy224;
	case '3':	goto yy226;
	default:	goto yy228;
	}
yy215:
yy216:
	++pos;
#line 731 "parsers/MshParser.c++.re2c"
	{ return TT_EOF;	}
#line 1832 "parsers/MshParser.c++"
yy218:
	++pos;
	yych = *pos;
	goto yy231;
yy219:
#line 732 "parsers/MshParser.c++.re2c"
	{ goto std;	}
#line 1840 "parsers/MshParser.c++"
yy220:
	++pos;
#line 733 "parsers/MshParser.c++.re2c"
	{ lex_state = 7; return TT_0_TAGS; }
#line 1845 "parsers/MshParser.c++"
yy222:
	++pos;
#line 734 "parsers/MshParser.c++.re2c"
	{ lex_state = 7; return TT_1_TAGS; }
#line 1850 "parsers/MshParser.c++"
yy224:
	++pos;
#line 735 "parsers/MshParser.c++.re2c"
	{ lex_state = 7; return TT_2_TAGS; }
#line 1855 "parsers/MshParser.c++"
yy226:
	++pos;
#line 736 "parsers/MshParser.c++.re2c"
	{ lex_state = 7; return TT_3_TAGS; }
#line 1860 "parsers/MshParser.c++"
yy228:
	++pos;
#line 737 "parsers/MshParser.c++.re2c"
	{ return TT_UNKNOWN_TOKEN; }
#line 1865 "parsers/MshParser.c++"
yy230:
	++pos;
	if (limit <= pos) YYFILL(1);
	yych = *pos;
yy231:
	switch (yych) {
	case ' ':	goto yy230;
	default:	goto yy219;
	}
}
#line 738 "parsers/MshParser.c++.re2c"

		}
		break;

	case 7:	// extract indexes until EOL
		{
	
#line 1884 "parsers/MshParser.c++"
{
	char yych;
	if ((limit - pos) < 2) YYFILL(2);
	yych = *pos;
	switch (yych) {
	case 0x00:	goto yy237;
	case '\n':	goto yy241;
	case ' ':	goto yy239;
	case '0':	goto yy234;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy236;
	default:	goto yy243;
	}
yy234:
	++pos;
yy235:
#line 745 "parsers/MshParser.c++.re2c"
	{ setIndex(); return TT_INDEX; }
#line 1910 "parsers/MshParser.c++"
yy236:
	yych = *++pos;
	goto yy248;
yy237:
	++pos;
#line 746 "parsers/MshParser.c++.re2c"
	{ return TT_EOF;	}
#line 1918 "parsers/MshParser.c++"
yy239:
	++pos;
	yych = *pos;
	goto yy246;
yy240:
#line 747 "parsers/MshParser.c++.re2c"
	{ goto std;	}
#line 1926 "parsers/MshParser.c++"
yy241:
	++pos;
#line 748 "parsers/MshParser.c++.re2c"
	{ lex_state = 4; line_number++; return TT_EOL; }
#line 1931 "parsers/MshParser.c++"
yy243:
	++pos;
#line 749 "parsers/MshParser.c++.re2c"
	{ return TT_UNKNOWN_TOKEN; }
#line 1936 "parsers/MshParser.c++"
yy245:
	++pos;
	if (limit <= pos) YYFILL(1);
	yych = *pos;
yy246:
	switch (yych) {
	case ' ':	goto yy245;
	default:	goto yy240;
	}
yy247:
	++pos;
	if (limit <= pos) YYFILL(1);
	yych = *pos;
yy248:
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy247;
	default:	goto yy235;
	}
}
#line 750 "parsers/MshParser.c++.re2c"

		}

		default:
			std::cerr << "Error: default lexer state" << std::endl;
			return TT_ERROR;
			break;
	}

	// should never be reached
	return TT_ERROR;
	#undef YYFILL
}


void MshParser::setIndex()
{
	long number;
	number = strtol(tok, &pos, 10);
	index_list.push_back(number);
}


void MshParser::setNumber()
{
	float number;
	number = strtod(tok, &pos);
	float_list.push_back(number);
}


void 
MshParser::setParserTable()
{
	table	[NT_START]		[TT_OPEN_MESH_FORMAT]	=	PR_START;

	table	[NT_DOCUMENT]		[TT_OPEN_MESH_FORMAT]	=	PR_DOCUMENT;

	table	[NT_HEADER]		[TT_OPEN_MESH_FORMAT]	=	PR_HEADER;

	table	[NT_MF_VERSION_NUMBER]	[TT_VERSION_2_1]	=	PR_MF_VERSION_NUMBER_2_1;
	table	[NT_MF_VERSION_NUMBER]	[TT_VERSION_2_2]	=	PR_MF_VERSION_NUMBER_2_2;
	table	[NT_MF_VERSION_NUMBER]	[TT_UNKNOWN_TOKEN]	=	PR_MF_VERSION_NUMBER_ERROR;	// error just in case

	table	[NT_MF_FILE_TYPE]	[TT_MF_FILE_TYPE_ASCII]	=	PR_MF_FILE_TYPE_ASCII;

	table	[NT_MF_DATA_SIZE]	[TT_MF_DATA_SIZE]	=	PR_MF_DATA_SIZE;

	table	[NT_NODES]			[TT_OPEN_NODES]		=	PR_NODES;
	table	[NT_N_NUMBER_OF_NODES]		[TT_INDEX]		=	PR_N_NUMBER_OF_NODES;
	table	[NT_N_NUMBER_OF_NODES_SET]	[TT_EOL]		=	PR_N_NUMBER_OF_NODES_SET;
	table	[NT_N_NODE_DEFINITION]		[TT_INDEX]		=	PR_N_NODE_DEFINITION;
	table	[NT_N_NODE_DEFINITION_SET]	[TT_EOL]		=	PR_N_NODE_DEFINITION_SET;

	table	[NT_N_NODE_DEFINITION_FOLLOW]	[TT_INDEX]		=	PR_N_NODE_DEFINITION_FOLLOW_1;
	table	[NT_N_NODE_DEFINITION_FOLLOW]	[TT_CLOSE_NODES]	=	PR_N_NODE_DEFINITION_FOLLOW_2;

	table	[NT_ELEMENTS]			[TT_OPEN_ELEMENTS]	=	PR_ELEMENTS;
	table	[NT_E_NUMBER_OF_ELEMENTS]	[TT_INDEX]		=	PR_E_NUMBER_OF_ELEMENTS;
	table	[NT_E_NUMBER_OF_ELEMENTS_SET]	[TT_EOL]		=	PR_E_NUMBER_OF_ELEMENTS_SET;
	table	[NT_E_ELEMENT_DEFINITION]	[TT_INDEX]		=	PR_E_ELEMENT_DEFINITION;

	table	[NT_E_ELEMENT_TYPE]	[TT_ELEMENT_TRIANGLE3]		=	PR_E_ELEMENT_TRIANGLE3;
	table	[NT_E_ELEMENT_TYPE]	[TT_ELEMENT_TRIANGLE6]		=	PR_E_ELEMENT_TRIANGLE6;
	table	[NT_E_ELEMENT_TYPE]	[TT_ELEMENT_QUADRANGLE4]	=	PR_E_ELEMENT_QUADRANGLE4;
	table	[NT_E_ELEMENT_TYPE]	[TT_ELEMENT_QUADRANGLE8]	=	PR_E_ELEMENT_QUADRANGLE8;
	table	[NT_E_ELEMENT_TYPE]	[TT_ELEMENT_QUADRANGLE9]	=	PR_E_ELEMENT_QUADRANGLE9;

	table	[NT_E_ELEMENT_TYPE_SET_ELEMENT]	[TT_EOL]	=	PR_E_ELEMENT_TYPE_SET_ELEMENT;
	table	[NT_E_ELEMENT_TYPE_SET_FORCE]	[TT_EOL]	=	PR_E_ELEMENT_TYPE_SET_FORCE;

	table	[NT_E_ELEMENT_TYPE]	[TT_ELEMENT_HEXAHEDRON8]	=	PR_E_ELEMENT_HEXAHEDRON8;
	table	[NT_E_ELEMENT_TYPE]	[TT_ELEMENT_HEXAHEDRON20]	=	PR_E_ELEMENT_HEXAHEDRON20;
	table	[NT_E_ELEMENT_TYPE]	[TT_ELEMENT_HEXAHEDRON27]	=	PR_E_ELEMENT_HEXAHEDRON27;
	table	[NT_E_ELEMENT_TYPE]	[TT_ELEMENT_TETRAHEDRON4]	=	PR_E_ELEMENT_TETRAHEDRON4;
	table	[NT_E_ELEMENT_TYPE]	[TT_ELEMENT_TETRAHEDRON10]	=	PR_E_ELEMENT_TETRAHEDRON10;
	table	[NT_E_ELEMENT_TYPE]	[TT_ELEMENT_PRISM6]	=	PR_E_ELEMENT_PRISM6;
	table	[NT_E_ELEMENT_TYPE]	[TT_ELEMENT_PRISM15]	=	PR_E_ELEMENT_PRISM15;
	table	[NT_E_ELEMENT_TYPE]	[TT_ELEMENT_PRISM18]	=	PR_E_ELEMENT_PRISM18;

	table	[NT_E_ELEMENT_DEFINITION_FOLLOW]	[TT_INDEX]		=	PR_E_ELEMENT_DEFINITION_FOLLOW_1;
	table	[NT_E_ELEMENT_DEFINITION_FOLLOW]	[TT_CLOSE_ELEMENTS]	=	PR_E_ELEMENT_DEFINITION_FOLLOW_2;

	table	[NT_E_TAGS]		[TT_0_TAGS]		=	PR_E_TAGS_0;
	table	[NT_E_TAGS]		[TT_1_TAGS]		=	PR_E_TAGS_1;
	table	[NT_E_TAGS]		[TT_2_TAGS]		=	PR_E_TAGS_2;
	table	[NT_E_TAGS]		[TT_3_TAGS]		=	PR_E_TAGS_3;

	table	[NT_E_TAGS_1_SET]	[TT_INDEX]		=	PR_E_TAGS_1_SET;
	table	[NT_E_TAGS_2_SET]	[TT_INDEX]		=	PR_E_TAGS_2_SET;
	table	[NT_E_TAGS_3_SET]	[TT_INDEX]		=	PR_E_TAGS_3_SET;

	table	[NT_ELEMENTS_SET]	[TT_EOL]		=	PR_ELEMENTS_SET;

	table	[NT_ELEMENTS_FOLLOW]	[TT_OPEN_NODE_DATA]		=	PR_ELEMENT_FOLLOW_1;
	table	[NT_ELEMENTS_FOLLOW]	[TT_OPEN_ELEMENT_DATA]		=	PR_ELEMENT_FOLLOW_2;
	table	[NT_ELEMENTS_FOLLOW]	[TT_OPEN_ELEMENT_NODE_DATA]	=	PR_ELEMENT_FOLLOW_3;
	table	[NT_ELEMENTS_FOLLOW]	[TT_EOF]			=	PR_ELEMENT_FOLLOW_4;

	//table	[NT_NODE_DATA]		[TT_OPEN_NODE_DATA]		=	PR_ELEMENT_FOLLOW_4;

	table	[NT_COORDINATE]		[TT_NUMBER]		=	PR_COORDINATE;
}


enum MshParser::Error::Type 
MshParser::operator() (std::istream &file, fem::Model &model)
{
	return parse(file, model);
}


void 
MshParser::setSurfaceLoadOperator(fem::SurfaceLoadOperator &surface_load_operator)
{
	this->surface_load_operator = &surface_load_operator;
}


