#ifndef ANALYSIS_RESULT_HPP
#define ANALYSIS_RESULT_HPP

#include <map>
#include <vector>

#include <boost/tuple/tuple.hpp>
#include <iostream>

#include "../lalib/Matrix.h++"
#include "../lalib/Vector.h++"

#include "RecoveredValues.h++"


namespace fem
{


/**
Class designed to store all the relevant analysis results which are generated by fem::Analysis and are needed in post-processing
**/
template<typename Scalar>
struct AnalysisResult 
{
	AnalysisResult() {};
	AnalysisResult(const AnalysisResult<Scalar> &);

	lalib::Matrix<Scalar,lalib::SparseDOK> K;
	lalib::Vector<Scalar> f;
	lalib::Vector<Scalar> d;

	std::map<size_t, boost::tuple<size_t,size_t,size_t> > lm;

	// map between a element reference and the element's recovered values
	std::vector<RecoveredValues<Scalar> >	recovered_values;
	typename RecoveredValues<Scalar>::Values maximum, minimum;


	void clear();
};


template<typename Scalar>
AnalysisResult<Scalar>::AnalysisResult(const AnalysisResult<Scalar> &copied)
{
	this->K = copied.K;
	this->f = copied.f;
	this->d = copied.d;

	this->lm = copied.lm;
	this->recovered_values = copied.recovered_values;
	this->maximum = copied.maximum;
	this->minimum = copied.minimum;
}


template<typename Scalar>
void AnalysisResult<Scalar>::clear()
{
	K.clear();
	f.clear();
	d.clear();

	lm.clear();
	recovered_values.clear();

	maximum = {0,0,0,0,0,0};
	minimum = {0,0,0,0,0,0};
}


}	// namespace fem


#endif
