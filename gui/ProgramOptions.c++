/* Generated by re2c 0.13.5 on Wed Apr  6 19:13:06 2011 */
#line 1 "ProgramOptions.c++.re2c"
/* Generated by re2c 0.13.5 on Fri Nov  6 17:46:44 2009 */
#line 1 "ProgramOptions.c++.re2c"
#include "ProgramOptions.h++"

#include <sys/stat.h>
#include <stdlib.h>
#include <string.h>

#include <vector>
#include <string>



Option::Option()
{
	value.number = 0;
}


Option::~Option()
{
}


void Option::setOption(double value, Level level)
{
	this->option_level = level;
	this->type = VAL_NUMBER;
	this->value.number = value;
}


void Option::setOption(std::string value, Level level)
{
	this->option_level = level;
	this->type = VAL_STRING;
	this->text = value;
}


void Option::setOption(bool value, Level level)
{
	this->option_level = level;
	this->type = VAL_BOOL;
	this->value.b = value;
}


void Option::setOption(std::vector<double> value, Level level)
{
	this->option_level = level;
	this->type = VAL_NUMBER_LIST;
	this->number_list = value;
}


double Option::getNumber()	
{
	 return value.number; 
}


std::string Option::getString()	
{
	 return text; 
}


bool Option::getBool()		
{
	 return value.b; 
}

std::vector<double> Option::getNumberList()		
{
	 return number_list;
}


ProgramOptions::ProgramOptions()
{
	option_level = Option::OPT_DEFAULT;
}


ProgramOptions::~ProgramOptions()
{
}

void ProgramOptions::setOption(const std::string option, int value)
{
	Option op;
	op.setOption((double)value, option_level);
	options_list[option] = op;
}


void ProgramOptions::setOption(const std::string option, long int value)
{
	Option op;
	op.setOption((double)value, option_level);
	options_list[option] = op;
}


void ProgramOptions::setOption(const std::string option, double value)
{
	Option op;
	op.setOption(value, option_level);
	options_list[option] = op;
}


void ProgramOptions::setOption(const std::string option, std::string value)
{
	Option op;
	op.setOption(value, option_level);
	options_list[option] = op;
}


void ProgramOptions::setOption(const std::string option, bool value)
{
	Option op;
	op.setOption(value, option_level);
	options_list[option] = op;
}


void ProgramOptions::setOption(const std::string option, std::vector<double> value)
{
	Option op;
	op.setOption(value, option_level);
	options_list[option] = op;
}


bool ProgramOptions::wasSet(const std::string text) const
{
	return (options_list.find(text) != options_list.end());
}


bool ProgramOptions::getOption(const std::string op, int &val)
{
	std::map<std::string, class Option>::iterator it;
	it = options_list.find(op);
	if(it != options_list.end())
	{
		if( it->second.isNumber())
		{
			val = (int)it->second.getNumber();
			return true;
		}
		else
		{
			std::cerr << "option " << op << " isn't a number" << std::endl;
			return false;
		}
	}
	else
	{
		std::cerr << "option " << op << " wasn't set" << std::endl;
		return false;
	}
}


bool ProgramOptions::getOption(const std::string op, long int &val)
{
	std::map<std::string, class Option>::iterator it;
	it = options_list.find(op);
	if(it != options_list.end())
	{
		if( it->second.isNumber())
		{
			val = (long int)it->second.getNumber();
			return true;
		}
		else
		{
			std::cerr << "option " << op << " isn't a number" << std::endl;
			return false;
		}
	}
	else
	{
		std::cerr << "option " << op << " wasn't set" << std::endl;
		return false;
	}
}


bool ProgramOptions::getOption(const std::string op, double &val)
{
	std::map<std::string, class Option>::iterator it;
	it = options_list.find(op);
	if(it != options_list.end())
	{
		if( it->second.isNumber())
		{
			val = it->second.getNumber();
			return true;
		}
		else
		{
			std::cerr << "option " << op << " isn't a float" << std::endl;
			return false;
		}
	}
	else
	{
		std::cerr << "option " << op << " wasn't set" << std::endl;
		return false;
	}
}


bool ProgramOptions::getOption(const std::string op, std::string &val)
{
	std::map<std::string, class Option>::iterator it;
	it = options_list.find(op);
	if(it != options_list.end())
	{
		if( it->second.isString())
		{
			val = it->second.getString();
			return true;
		}
		else
		{
			std::cerr << "option " << op << " isn't a text" << std::endl;
			return false;
		}
	}
	else
	{
		std::cerr << "option " << op << " wasn't set" << std::endl;
		return false;
	}
}


bool ProgramOptions::getOption(const std::string op, bool &val)
{
	std::map<std::string, class Option>::iterator it;
	it = options_list.find(op);
	if(it != options_list.end())
	{
		if( it->second.isBool())
		{
			val = it->second.getBool();
			return true;
		}
		else
		{
			std::cerr << "option " << op << " isn't a bool" << std::endl;
			return false;
		}
	}
	else
	{
		std::cerr << "option " << op << " wasn't set" << std::endl;
		return false;
	}
}


bool ProgramOptions::getOption(const std::string op, std::vector<double> &val)
{
	std::map<std::string, class Option>::iterator it;
	it = options_list.find(op);
	if(it != options_list.end())
	{
		if( it->second.isNumberList())
		{
			val = it->second.getNumberList();
			return true;
		}
		else
		{
			std::cerr << "option " << op << " isn't a number list" << std::endl;
			return false;
		}
	}
	else
	{
		std::cerr << "option " << op << " wasn't set" << std::endl;
		return false;
	}
}


std::ostream& operator << (std::ostream& os, ProgramOptions &prog)
{
	/*TODO implement this */
	std::map<std::string, Option>::iterator it;
	for(it = prog.options_list.begin(); it != prog.options_list.end(); it++)
	{
		os << (*it).first << " = ";
		switch( (*it).second.type)
		{	
			case Option::VAL_NUMBER:
				os << (*it).second.value.number << std::endl;
				break;

			case Option::VAL_STRING:
				os << "\"" << (*it).second.text << "\"" << std::endl;
				break;

			case Option::VAL_BOOL:
				os << ( (*it).second.value.b ? "true": "false") << std::endl;
				break;

			case Option::VAL_NUMBER_LIST:	
				os << "{ ";
				for(std::vector<double>::iterator ni = (*it).second.number_list.begin(); ni != (*it).second.number_list.end(); ni++)
				{
					if(ni != (*it).second.number_list.begin())
						os << ", ";
					os << *ni;
				}
				os << "}" << std::endl;
				break;

			default:
				/* this section is never reached */
				break;
		}
	}
	return os;
}

int ProgramOptions::importFile(std::istream &is, std::string prefix)
{
	Parser *p = new Parser();

	switch(p->parse(*this, is, prefix))
	{
		case 0:
			break;

		default:
			/*TODO implement error handling */
			break;
	}

	delete p;
	return 0;
}


ProgramOptions::Parser::Parser()
{
	buffer[0] = '\0';
	pos = tok = lim = buffer;
	lex_state = 0;
	value.number = 0;
}


ProgramOptions::Parser::~Parser()
{
}


void ProgramOptions::Parser::fill(std::istream &is)
{
	// move the remaining unprocessed buffer to the start
	if(lim-tok > 0 )
	{
		memcpy(buffer,tok,lim-tok);
		pos = buffer + (pos - tok);
	}
	else
	{
		pos = buffer;
	}
	tok = buffer;

	// fill the vacant space
	is.read(buffer + (lim-tok), 1024-(lim-buffer));
	lim = buffer + is.gcount();
}


enum ProgramOptions::Parser::LEXER_TOKENS ProgramOptions::Parser::lexer(std::istream &is)
{
	std::string tmp;
	if(is.bad())
		return LEX_STREAM_ERROR;

std:
	tok = pos;
	#define YYFILL(n) { if(is.eof()){ if(tok == lim) return LEX_EOF; }else fill(is); }
	#define CP { tmp.clear(); tmp.append(tok,pos-tok); }
	#define CPo { text.clear(); text.append(tok,pos-tok); }
	#define CPs { text.clear(); text.append(tok+1,pos-tok-2); }

	switch(lex_state)
	{
		case 0:	// starting
		{
	
#line 408 "ProgramOptions.c++"
{
	char yych;

	if ((lim - pos) < 2) YYFILL(2);
	yych = *pos;
	switch (yych) {
	case '\t':
	case ' ':	goto yy10;
	case '\n':	goto yy8;
	case '.':	goto yy2;
	case '=':	goto yy4;
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy6;
	default:	goto yy12;
	}
yy2:
	++pos;
#line 417 "ProgramOptions.c++.re2c"
	{ return LEX_OPTION_SEPARATOR; }
#line 478 "ProgramOptions.c++"
yy4:
	++pos;
#line 418 "ProgramOptions.c++.re2c"
	{ lex_state = 1; return LEX_OPTION_ASSIGN; }
#line 483 "ProgramOptions.c++"
yy6:
	++pos;
	yych = *pos;
	goto yy17;
yy7:
#line 419 "ProgramOptions.c++.re2c"
	{ CPo; return LEX_OPTION_NAME; }
#line 491 "ProgramOptions.c++"
yy8:
	++pos;
#line 420 "ProgramOptions.c++.re2c"
	{ return LEX_EOL; }
#line 496 "ProgramOptions.c++"
yy10:
	++pos;
	yych = *pos;
	goto yy15;
yy11:
#line 421 "ProgramOptions.c++.re2c"
	{ goto std;}
#line 504 "ProgramOptions.c++"
yy12:
	++pos;
#line 422 "ProgramOptions.c++.re2c"
	{ return LEX_UNKNOWN_TOKEN; }
#line 509 "ProgramOptions.c++"
yy14:
	++pos;
	if (lim <= pos) YYFILL(1);
	yych = *pos;
yy15:
	switch (yych) {
	case '\t':
	case ' ':	goto yy14;
	default:	goto yy11;
	}
yy16:
	++pos;
	if (lim <= pos) YYFILL(1);
	yych = *pos;
yy17:
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy16;
	default:	goto yy7;
	}
}
#line 423 "ProgramOptions.c++.re2c"

	}
	break;

	case 1:	// only parses values
	{
	
#line 600 "ProgramOptions.c++"
{
	char yych;
	unsigned int yyaccept = 0;
	if ((lim - pos) < 5) YYFILL(5);
	yych = *pos;
	switch (yych) {
	case '\t':
	case ' ':	goto yy36;
	case '\n':	goto yy34;
	case '"':	goto yy25;
	case ',':	goto yy32;
	case '-':	goto yy20;
	case '0':	goto yy22;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy24;
	case 'f':	goto yy27;
	case 't':	goto yy26;
	case '{':	goto yy28;
	case '}':	goto yy30;
	default:	goto yy38;
	}
yy20:
	++pos;
	switch ((yych = *pos)) {
	case '0':	goto yy64;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy55;
	default:	goto yy21;
	}
yy21:
#line 439 "ProgramOptions.c++.re2c"
	{ return LEX_UNKNOWN_TOKEN; }
#line 647 "ProgramOptions.c++"
yy22:
	yyaccept = 0;
	yych = *(marker = ++pos);
	switch (yych) {
	case '.':	goto yy57;
	default:	goto yy23;
	}
yy23:
#line 430 "ProgramOptions.c++.re2c"
	{ CP; value.number = atof(tmp.c_str()); return LEX_NUMBER; }
#line 658 "ProgramOptions.c++"
yy24:
	yyaccept = 0;
	yych = *(marker = ++pos);
	goto yy56;
yy25:
	yyaccept = 1;
	yych = *(marker = ++pos);
	switch (yych) {
	case '"':	goto yy53;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy51;
	default:	goto yy21;
	}
yy26:
	yyaccept = 1;
	yych = *(marker = ++pos);
	switch (yych) {
	case 'r':	goto yy47;
	default:	goto yy21;
	}
yy27:
	yyaccept = 1;
	yych = *(marker = ++pos);
	switch (yych) {
	case 'a':	goto yy41;
	default:	goto yy21;
	}
yy28:
	++pos;
#line 434 "ProgramOptions.c++.re2c"
	{ return LEX_OPEN_VECTOR; 	}
#line 750 "ProgramOptions.c++"
yy30:
	++pos;
#line 435 "ProgramOptions.c++.re2c"
	{ return LEX_CLOSE_VECTOR; 	}
#line 755 "ProgramOptions.c++"
yy32:
	++pos;
#line 436 "ProgramOptions.c++.re2c"
	{ return LEX_VECTOR_SEPARATOR; 	}
#line 760 "ProgramOptions.c++"
yy34:
	++pos;
#line 437 "ProgramOptions.c++.re2c"
	{ lex_state = 0; return LEX_EOL; }
#line 765 "ProgramOptions.c++"
yy36:
	++pos;
	yych = *pos;
	goto yy40;
yy37:
#line 438 "ProgramOptions.c++.re2c"
	{ goto std;	}
#line 773 "ProgramOptions.c++"
yy38:
	yych = *++pos;
	goto yy21;
yy39:
	++pos;
	if (lim <= pos) YYFILL(1);
	yych = *pos;
yy40:
	switch (yych) {
	case '\t':
	case ' ':	goto yy39;
	default:	goto yy37;
	}
yy41:
	yych = *++pos;
	switch (yych) {
	case 'l':	goto yy43;
	default:	goto yy42;
	}
yy42:
	pos = marker;
	switch (yyaccept) {
	case 0: 	goto yy23;
	case 1: 	goto yy21;
	}
yy43:
	yych = *++pos;
	switch (yych) {
	case 's':	goto yy44;
	default:	goto yy42;
	}
yy44:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy45;
	default:	goto yy42;
	}
yy45:
	++pos;
#line 433 "ProgramOptions.c++.re2c"
	{ value.b = false; return LEX_BOOL; }
#line 815 "ProgramOptions.c++"
yy47:
	yych = *++pos;
	switch (yych) {
	case 'u':	goto yy48;
	default:	goto yy42;
	}
yy48:
	yych = *++pos;
	switch (yych) {
	case 'e':	goto yy49;
	default:	goto yy42;
	}
yy49:
	++pos;
#line 432 "ProgramOptions.c++.re2c"
	{ value.b = true; return LEX_BOOL; }
#line 832 "ProgramOptions.c++"
yy51:
	++pos;
	if (lim <= pos) YYFILL(1);
	yych = *pos;
	switch (yych) {
	case '"':	goto yy53;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy51;
	default:	goto yy42;
	}
yy53:
	++pos;
#line 431 "ProgramOptions.c++.re2c"
	{ CPs; return LEX_STRING; 	}
#line 907 "ProgramOptions.c++"
yy55:
	yyaccept = 0;
	marker = ++pos;
	if ((lim - pos) < 2) YYFILL(2);
	yych = *pos;
yy56:
	switch (yych) {
	case '.':	goto yy57;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy55;
	default:	goto yy23;
	}
yy57:
	yych = *++pos;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy58;
	default:	goto yy42;
	}
yy58:
	yyaccept = 0;
	marker = ++pos;
	if ((lim - pos) < 3) YYFILL(3);
	yych = *pos;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy58;
	case 'E':
	case 'e':	goto yy60;
	default:	goto yy23;
	}
yy60:
	yych = *++pos;
	switch (yych) {
	case '+':
	case '-':	goto yy61;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy62;
	default:	goto yy42;
	}
yy61:
	yych = *++pos;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy62;
	default:	goto yy42;
	}
yy62:
	++pos;
	if (lim <= pos) YYFILL(1);
	yych = *pos;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy62;
	default:	goto yy23;
	}
yy64:
	yyaccept = 0;
	yych = *(marker = ++pos);
	switch (yych) {
	case '.':	goto yy57;
	default:	goto yy23;
	}
}
#line 440 "ProgramOptions.c++.re2c"

	}
	break;
	}
	#undef YYFILL
	#undef CP
	#undef CPo
	#undef CPs
	return LEX_ERROR;
}


int ProgramOptions::Parser::parse(ProgramOptions &op, std::istream &is, std::string prefix )
{
	using namespace std;

	#define WARN() {cerr << "ProgramOptions::Parser error at line "<< line << ", state " << state << " defaulted" << std::endl; state = 20;}

	int state = 0;
	enum LEXER_TOKENS token = LEX_UNKNOWN_TOKEN;
	vector<string> opname;
	string temp_string;
	vector<double> temp_number_list;
	vector<string>::iterator it;
	size_t line = 1;
	
	do {
		token = lexer(is);
		switch(state)
		{
			case 0:	// starting point
				switch(token)
				{
					case LEX_EOL:
						line++;
						break;

					case LEX_OPTION_NAME:
						opname.push_back(text);
						state = 1;	// object pushed
						break;

					case LEX_EOF:
						/*TODO implement decent return codes */
						return 0;
						break;

					default:
						WARN();
						break;
				}
				break;

			case 1:	// object pushed
				switch(token)
				{
					case LEX_OPTION_SEPARATOR:
						state = 2;	// waiting for object name
						break;

					case LEX_OPTION_ASSIGN:
						state = 3;	// waiting for option's value
						break;

					default:
						WARN();
						break;
				}
				break;

			case 2:	// waiting for object name
				switch(token)
				{
					case LEX_OPTION_NAME:
						opname.push_back(text);
						state = 1;	// object pushed
						break;

					default:
						WARN();
						break;
				}
				break;

			case 3:	// waiting for option's value
				temp_string.clear();
				if(!prefix.empty())
				{
					temp_string = prefix;
					if(!opname.empty()) 
						temp_string += ".";
				}
				// generate string with full option name
				it = opname.begin();
				temp_string += *it;
				for(it++; it != opname.end(); it++)
				{
					temp_string += "." + *it;
				}
				switch(token)
				{
					case LEX_NUMBER:
						state = 5;	// wait for EOL before committing float
						break;

					case LEX_STRING:
						state = 6;	// wait for EOL before committing string
						break;

					case LEX_BOOL:
						state = 7;	// wait for EOL before committing bool
						break;

					case LEX_OPEN_VECTOR:	// start vector
						state = 8;
						break;

					default:
						WARN();
						break;
				}
				break;


			case 5:	// wait for EOL before committing float
				switch(token)
				{
					case LEX_EOL:
						line++;
						op.setOption(temp_string, value.number);
						temp_string.clear();
						opname.clear();	//TODO implement support the compact format
						state = 0;
						break;

					case LEX_EOF:
						op.setOption(temp_string, value.number);
						return 0;	//TODO implement support the compact format
						break;

					default:
						WARN();
						break;
				}
				break;

			case 6:	// wait for EOL before committing string
				switch(token)
				{
					case LEX_EOL:
						line++;
						op.setOption(temp_string, text);
						temp_string.clear();
						opname.clear();	//TODO implement support the compact format
						state = 0;
						break;

					case LEX_EOF:
						op.setOption(temp_string, text);
						return 0;	//TODO implement support the compact format
					default:
						WARN();
						break;
				}
				break;

			case 7:	// wait for EOL before committing bool
				switch(token)
				{
					case LEX_EOL:
						line++;
						op.setOption(temp_string, value.b);
						temp_string.clear();
						opname.clear();	//TODO implement support the compact format
						state = 0;
						break;

					case LEX_EOF:
						op.setOption(temp_string, value.b);
						return 0;	//TODO implement support the compact format
					default:
						WARN();
						break;
				}
				break;

			case 8:	// start vector
				switch(token)
				{
					case LEX_NUMBER:
						temp_number_list.clear();
						temp_number_list.push_back(value.number);
						state = 9;	// continue vector
						break;

					default:
						WARN();
						break;
				}
				break;

			case 9:	// continue vector: separator or end
				switch(token)
				{
					case LEX_VECTOR_SEPARATOR:
						state = 10;	// continue vector: number
						break;

					case LEX_CLOSE_VECTOR:
						state = 11;	// wait for EOL before committing 
						break;

					default:
						WARN();
						break;
				}
				break;

			case 10:	// continue vector: number
				switch(token)
				{
					case LEX_NUMBER:
						temp_number_list.push_back(value.number);
						state = 9;
						break;

					default:
						WARN();
						break;
				}
				break;

			case 11:
				switch(token)
				{
					case LEX_EOL:
						line++;
						op.setOption(temp_string, temp_number_list);
						temp_string.clear();
						opname.clear();	//TODO implement support the compact format
						state = 0;
						break;

					case LEX_EOF:
						op.setOption(temp_string, temp_number_list);
						return 0;	//TODO implement support the compact format
						break;

					default:
						WARN();
						break;
				}
				break;

			case 20:	// wait until EOL
				switch(token)
				{
					case LEX_EOL:
						line++;
					case LEX_EOF:
						state = 0;
						break;

					default:
						break;
				}
				break;

			default:
				WARN();
				break;
		}
	} while ((token != LEX_EOF) && (token != LEX_STREAM_ERROR));

	/*TODO set a decent return code */
	return 0;
	#undef WARN
}
