/* Generated by re2c 0.13.5 on Fri Nov  6 17:46:44 2009 */
#line 1 "ProgramOptions.c++.re2c"
#include "ProgramOptions.h++"

#include <sys/stat.h>
#include <stdlib.h>
#include <string.h>



ProgramOptions::Option::Option()
{
}


ProgramOptions::Option::~Option()
{
}


void ProgramOptions::Option::setOption(long int value, OPTIONS_LEVEL level)
{
	this->option_level = level;
	this->type = VAL_INTEGER;
	this->value.integer = value;
}


void ProgramOptions::Option::setOption(double value, OPTIONS_LEVEL level)
{
	this->option_level = level;
	this->type = VAL_FLOAT;
	this->value.fp = value;
}


void ProgramOptions::Option::setOption(std::string value, OPTIONS_LEVEL level)
{
	this->option_level = level;
	this->type = VAL_STRING;
	this->value.text = value.c_str();
}


ProgramOptions::ProgramOptions()
{
}


ProgramOptions::~ProgramOptions()
{
}


void ProgramOptions::loadOptionsFromFile(std::string file, Option::OPTIONS_LEVEL level, std::string prefix)
{
	struct stat buffer;

	if(file.empty())
		return;
	/* check if system directory exists */
	if(stat(file.c_str(), &buffer) != 0)
		std::cerr << file << " doesn't exist" << std::endl;

	/*TODO load options from file */
}




std::ostream& operator << (std::ostream& os, ProgramOptions &prog)
{
	/*TODO implement this */
	return os;
}


enum ProgramOptions::LEXER_TOKENS ProgramOptions::lexer(struct ProgramOptions::lexer_values &v, std::istream &is)
{
	char *tmp;
	if(is.bad())
		return ProgramOptions::LEX_STREAM_ERROR;

std:
	v.tok = v.pos;
	#define YYFILL(n) { std::cout << "\nfill\n"; if(is.eof()) return ProgramOptions::LEX_EOF; else v.fill(is); }
	#define CP { tmp = new char [v.pos-v.tok+1] ; strncpy(tmp,v.tok,v.pos-v.tok); }
	#define CPo { v.value.text = new char [v.pos-v.tok+1] ; strncpy(v.value.text,v.tok,v.pos-v.tok); }
	#define CPs { v.value.text = new char [v.pos-v.tok+1] ; strncpy(v.value.text,v.tok+1,v.pos-v.tok-2); }
	/*!re2c
	re2c:yyfill:enable   	= 1;
	re2c:define:YYCTYPE  	= "char";
	re2c:define:YYCURSOR 	= v.pos;
	re2c:define:YYMARKER 	= v.marker;
	re2c:define:YYLIMIT	= v.lim;

	integer = "-"? ("0"|[1-9][0-9]*);
	option	= [a-zA-Z]+;
	float	= integer "." [0-9]+([eE][+-]?[0-9]+)?;
	string	= '"' [a-zA-Z0-9]* '"';

	'.'	{ return ProgramOptions::LEX_OPTION_SEPARATOR; }
	'='	{ return ProgramOptions::LEX_OPTION_ASSIGN; }
	option	{ CPo; return ProgramOptions::LEX_OPTION_NAME; }
	integer	{ CP; v.value.integer = atoi(tmp); delete [] tmp; return ProgramOptions::LEX_INTEGER; }
	float	{ CP; v.value.fp = atof(tmp); delete [] tmp; return ProgramOptions::LEX_FLOAT; }
	string	{ CPs; return ProgramOptions::LEX_STRING; }
	'\n'	{ return ProgramOptions::LEX_EOL; }
	' '+	{ goto std;}
	.	{ return ProgramOptions::LEX_UNKNOWN_TOKEN; }
	*/
	#undef YYFILL(n)
	#undef CP
	#undef CPo
	#undef CPs
	return ProgramOptions::LEX_ERROR;
}


ProgramOptions::lexer_values::lexer_values()
{
	buffer[0] = '\0';
	pos = tok = lim = buffer;
	value.integer = 0;
}


ProgramOptions::lexer_values::~lexer_values()
{
}


void ProgramOptions::lexer_values::fill(std::istream &is)
{
	// move the remaining unprocessed buffer to the start
	if(lim-tok > 0 )
	{
		memcpy(buffer,tok,lim-tok);
		pos = buffer + (pos - tok);
	}
	else
	{
		pos = buffer;
	}
	tok = buffer;

	// fill the vacant space
	is.read(buffer + (lim-tok), 1024-(lim-buffer));
	lim = buffer + is.gcount();
}


