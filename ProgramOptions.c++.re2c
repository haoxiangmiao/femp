/* Generated by re2c 0.13.5 on Fri Nov  6 17:46:44 2009 */
#line 1 "ProgramOptions.c++.re2c"
#include "ProgramOptions.h++"

#include <sys/stat.h>
#include <stdlib.h>
#include <string.h>

#include <vector>
#include <string>



ProgramOptions::Option::Option()
{
}


ProgramOptions::Option::~Option()
{
}


void ProgramOptions::Option::setOption(long int value, OPTIONS_LEVEL level)
{
	this->option_level = level;
	this->type = VAL_INTEGER;
	this->value.integer = value;
}


void ProgramOptions::Option::setOption(double value, OPTIONS_LEVEL level)
{
	this->option_level = level;
	this->type = VAL_FLOAT;
	this->value.fp = value;
}


void ProgramOptions::Option::setOption(std::string value, OPTIONS_LEVEL level)
{
	this->option_level = level;
	this->type = VAL_STRING;
	this->text = value;
}


ProgramOptions::ProgramOptions()
{
	option_level = Option::OPT_DEFAULT;
}


ProgramOptions::~ProgramOptions()
{
}


void ProgramOptions::loadOptionsFromFile(std::string file, Option::OPTIONS_LEVEL level, std::string prefix)
{
	struct stat buffer;

	if(file.empty())
		return;
	/* check if system directory exists */
	if(stat(file.c_str(), &buffer) != 0)
		std::cerr << file << " doesn't exist" << std::endl;

	/*TODO load options from file */
}


void ProgramOptions::setOption(std::string option, long int value, Option::OPTIONS_LEVEL level)
{
	Option op;
	op.setOption(value, level);
	options_list[option] = op;
}


void ProgramOptions::setOption(std::string option, double value, Option::OPTIONS_LEVEL level)
{
	Option op;
	op.setOption(value, level);
	options_list[option] = op;
}


void ProgramOptions::setOption(std::string option, std::string value, Option::OPTIONS_LEVEL level)
{
	Option op;
	op.setOption(value, level);
	options_list[option] = op;
}


std::ostream& operator << (std::ostream& os, ProgramOptions &prog)
{
	/*TODO implement this */
	std::map<std::string, ProgramOptions::Option>::iterator it;
	for(it = prog.options_list.begin(); it != prog.options_list.end(); it++)
	{
		os << (*it).first << " = ";
		switch( (*it).second.type)
		{	
			case ProgramOptions::Option::VAL_INTEGER:
				os << (*it).second.value.integer << std::endl;
				break;

			case ProgramOptions::Option::VAL_FLOAT:
				os << (*it).second.value.fp << std::endl;
				break;

			case ProgramOptions::Option::VAL_STRING:
				os << "\"" << (*it).second.text << "\"" << std::endl;
				break;

			default:
				/* this section is never reached */
				break;
		}
	}
	return os;
}


ProgramOptions::Parser::Parser()
{
	buffer[0] = '\0';
	pos = tok = lim = buffer;
	value.integer = 0;
}


ProgramOptions::Parser::~Parser()
{
}


void ProgramOptions::Parser::fill(std::istream &is)
{
	// move the remaining unprocessed buffer to the start
	if(lim-tok > 0 )
	{
		memcpy(buffer,tok,lim-tok);
		pos = buffer + (pos - tok);
	}
	else
	{
		pos = buffer;
	}
	tok = buffer;

	// fill the vacant space
	is.read(buffer + (lim-tok), 1024-(lim-buffer));
	lim = buffer + is.gcount();
}


enum ProgramOptions::Parser::LEXER_TOKENS ProgramOptions::Parser::lexer(std::istream &is)
{
	std::string tmp;
	if(is.bad())
		return LEX_STREAM_ERROR;

std:
	tok = pos;
	#define YYFILL(n) { std::cout << "\nfill\n"; if(is.eof()) return LEX_EOF; else fill(is); }
	#define CP { tmp.clear(); tmp.append(tok,pos-tok); }
	#define CPo { text.clear(); text.append(tok,pos-tok); }
	#define CPs { text.clear(); text.append(tok+1,pos-tok-2); }
	/*!re2c
	re2c:yyfill:enable   	= 1;
	re2c:define:YYCTYPE  	= "char";
	re2c:define:YYCURSOR 	= pos;
	re2c:define:YYMARKER 	= marker;
	re2c:define:YYLIMIT	= lim;

	integer = "-"? ("0"|[1-9][0-9]*);
	option	= [a-zA-Z]+;
	float	= integer "." [0-9]+([eE][+-]?[0-9]+)?;
	string	= '"' [a-zA-Z0-9]* '"';
	indent	= [\t];

	'.'	{ return LEX_OPTION_SEPARATOR; }
	'='	{ return LEX_OPTION_ASSIGN; }
	indent	{ return LEX_INDENT; }
	option	{ CPo; return LEX_OPTION_NAME; }
	integer	{ CP; value.integer = atoi(tmp.c_str()); return LEX_INTEGER; }
	float	{ CP; value.fp = atof(tmp.c_str()); return LEX_FLOAT; }
	string	{ CPs; return LEX_STRING; }
	'\n'	{ return LEX_EOL; }
	' '+	{ goto std;}
	.	{ return LEX_UNKNOWN_TOKEN; }
	*/
	#undef YYFILL(n)
	#undef CP
	#undef CPo
	#undef CPs
	return LEX_ERROR;
}


int ProgramOptions::Parser::parse(ProgramOptions &op, std::istream &is, ProgramOptions::Option::OPTIONS_LEVEL level, std::string prefix )
{
	using namespace std;

	int state = 0;
	enum LEXER_TOKENS token = LEX_UNKNOWN_TOKEN;
	vector<string> opname;
	string temp;
	vector<string>::iterator it;
	size_t line = 0;
	
	do {
		token = lexer(is);
		switch(state)
		{
			case 0:	// starting point
				switch(token)
				{
					case LEX_EOL:
						line++;
						break;

					case LEX_OPTION_NAME:
						opname.push_back(text);
						state = 1;	// object pushed
						break;

					case LEX_EOF:
						/*TODO implement decent return codes */
						return 0;
						break;

					default:
						cerr << "state " << state << " defaulted\n";
						break;
				}
				break;

			case 1:	// object pushed
				switch(token)
				{
					case LEX_OPTION_SEPARATOR:
						state = 2;	// waiting for object name
						break;

					case LEX_OPTION_ASSIGN:
						state = 3;	// waiting for option's value
						break;

					default:
						cerr << "state " << state << " defaulted\n";
						break;
				}
				break;

			case 2:	// waiting for object name
				switch(token)
				{
					case LEX_OPTION_NAME:
						opname.push_back(text);
						state = 1;	// object pushed
						break;

					default:
						cerr << "state " << state << " defaulted\n";
						break;
				}
				break;

			case 3:	// waiting for option's value
				switch(token)
				{
					case LEX_INTEGER:
						it = opname.begin();
						temp = prefix + *it;
						// generate string with full option name
						for(it++; it != opname.end(); it++)
						{
							temp += "." + *it;
						}
						state = 4;	// wait for EOL before committing integer
						break;

					case LEX_FLOAT:
						it = opname.begin();
						temp = prefix + *it;
						// generate string with full option name
						for(it++; it != opname.end(); it++)
						{
							temp += "." + *it;
						}
						state = 5;	// wait for EOL before committing float
						break;

					case LEX_STRING:
						it = opname.begin();
						temp = prefix + *it;
						// generate string with full option name
						for(it++; it != opname.end(); it++)
						{
							temp += "." + *it;
						}
						state = 6;	// wait for EOL before committing string
						break;

					default:
						cerr << "state " << state << " defaulted\n";
						break;
				}
				break;

			case 4:	// wait for EOL before committing integer
				switch(token)
				{
					case LEX_EOL:
						line++;
						op.setOption(temp, value.integer, level);
						temp.clear();
						opname.clear();	//TODO implement support the compact format
						state = 0;
						break;

					case LEX_EOF:
						op.setOption(temp, value.integer, level);
						return 0;	//TODO implement support the compact format
						break;

					default:
						cerr << "state " << state << " defaulted\n";
						state = 20;	// wait until EOL
						break;
				}
				break;

			case 5:	// wait for EOL before committing float
				switch(token)
				{
					case LEX_EOL:
						line++;
						op.setOption(temp, value.fp, level);
						temp.clear();
						opname.clear();	//TODO implement support the compact format
						state = 0;
						break;

					case LEX_EOF:
						op.setOption(temp, value.fp, level);
						return 0;	//TODO implement support the compact format
						break;

					default:
						cerr << "state " << state << " defaulted\n";
						break;
				}
				break;

			case 6:	// wait for EOL before committing string
				switch(token)
				{
					case LEX_EOL:
						line++;
						op.setOption(temp, text, level);
						temp.clear();
						opname.clear();	//TODO implement support the compact format
						state = 0;
						break;

					case LEX_EOF:
						op.setOption(temp, text, level);
						return 0;	//TODO implement support the compact format
					default:
						cerr << "state " << state << " defaulted\n";
						break;
				}
				break;

			case 20:	// wait until EOL
				switch(token)
				{
					case LEX_EOL:
						state = 0;
						line++;
						break;

					default:
						cerr << "state " << state << " defaulted\n";
						break;
				}
				break;

			default:
				cerr << "reached invalid state\n";
				break;
		}
	} while ((token != LEX_EOF) && (token != LEX_STREAM_ERROR));

	/*TODO set a decent return code */
	return 0;

}
